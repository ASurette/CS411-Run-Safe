//Google stuff
var rendererOptions = {draggable: true, polylineOptions:{strokeColor:"#FF0000"} };
var directionsDisplay = new google.maps.DirectionsRenderer(rendererOptions);
var directionsService = new google.maps.DirectionsService();
var geocoder;

var adsf = 77;

//The map, related stuff, and other icons
var map;
var center;
var baseSet = new Boolean();
var BaseMarker;
var BaseMarkerAction;
//var homeIcon = './RLimages/Home.png';
var pitchMarker;
var BaseLocation = new google.maps.LatLng(42.349,-71.104); //111 Cummington Mall
var elevator;

//The current route
var travelMode,travelDirection,travelHeading;
var allowFerries = false;
var avoidHighways = true;
//Stuff for keeping a copy of the route before this one
var tcxSpeed;
var markerArray = [];
var markerPosition = [];
var markerLabel = [];
// var markerTime = [];
var Country;
var tooLong = 0;
var tooShort = 0;
var scaleFactor = 0.80;
var scaleCount = 0;
var currentRouteData = [];  //An array to start storing away anything you want to know on a point-by-point basis.
var spacedRouteData = []; //The array of data generated by interpolating Google's returned data.
var useThis = spacedRouteData;
var fixedPoints = new Array;
var rlPoints = new Array();
var rlPointsNew = new Array(); //use this for cleaning up the little tails
var routeResult;
var routeLatLng = new Array;
var totalDistanceInCurrentUnits;
var requestedLengthInMeters;
var targetLengthInMeters; //This one is adjusted by the scale factor to try and zero in on the length you want.
var rlPoints = new Array();
// var Velocity,Time,Dist;
var countCalcs=0;

//Previous routes
var resultHistory = new Array;
var historyPointer;
var storeInHistory;
var lastRemoved = -1;

// Stuff for when a URL contains inputs (a permalink)
var uBase;
var urlPoints = new Array();
// var utMode;
var ulen;
var uuS;
var uClean;
var parsedUrl = false;
// var haveGoodUrl = false;

// Stuff for when that permalink stuff is old, from an old version.
var haveOldUrl = new Boolean();
var haveEmbedded = new Boolean();
var oldUrlLng,oldUrlLat;
var oldUrlLen;
var oldUrlRnd;

var mileMarkers = [];
var rideStart;  //This is the day and time of the start of the ride, used for predicting the weather.


// Load the Visualization API and the columnchart package.
google.load("visualization", "1", {packages: ["columnchart"]});
var elevDist = [];

//For importing GPS files
var importedTracks = new Array;

//Cleaning up the tails
var DoClean = true;
var countCalcs = 0; //Count how many times you call calcRoute()

//Various flags
var ePlot = false;
var showingMarkers = false;
var showingCrime = false;
var infowindow = new google.maps.InfoWindow({
    content: '',
    maxWidth: 400
});

//Language
var Language = new String();

//Units
var MILES2KM = 5280*12*2.54/100/1000;
var KM2MILES = 1/MILES2KM;
var Feet2Meters = 12*2.54/100;

//Cue sheet
var Directions;

//Crime markers
var crime_markers = [];

//New map tile layers.
var OpenCycleMapTypeOptions = {
    getTileUrl: function(coord, zoom) {
        var normalizedCoord = getNormalizedCoord(coord, zoom);
        if (!normalizedCoord) {
            return null;
        }
        var bound = Math.pow(2, zoom);
        return 'http://tile.thunderforest.com/cycle' +
            '/' + zoom + '/' + normalizedCoord.x + '/' + normalizedCoord.y + '.png' + '?apikey=16ee5a6bac6f4f58860ec7cda4bb0f51';
    },
    tileSize: new google.maps.Size(256, 256),
    maxZoom: 18,
    minZoom: 0,
    radius: 6371000,
    name: 'OpenCycleMap'
};
var OpenCycleMapType = new google.maps.ImageMapType(OpenCycleMapTypeOptions);
var OpenTransportMapTypeOptions = {
    getTileUrl: function(coord, zoom) {
        var normalizedCoord = getNormalizedCoord(coord, zoom);
        if (!normalizedCoord) {
            return null;
        }
        var bound = Math.pow(2, zoom);
        return 'http://tile.thunderforest.com/transport' +
            '/' + zoom + '/' + normalizedCoord.x + '/' + normalizedCoord.y + '.png'  + '?apikey=16ee5a6bac6f4f58860ec7cda4bb0f51';
    },
    tileSize: new google.maps.Size(256, 256),
    maxZoom: 21,
    minZoom: 0,
    radius: 6371000,
    name: 'OpenTransportMap'
};
var OpenTransportMapType = new google.maps.ImageMapType(OpenTransportMapTypeOptions);
var OpenLandscapeMapTypeOptions = {
    getTileUrl: function(coord, zoom) {
        var normalizedCoord = getNormalizedCoord(coord, zoom);
        if (!normalizedCoord) {
            return null;
        }
        var bound = Math.pow(2, zoom);
        return 'http://tile.thunderforest.com/landscape' +
            '/' + zoom + '/' + normalizedCoord.x + '/' + normalizedCoord.y + '.png'  + '?apikey=16ee5a6bac6f4f58860ec7cda4bb0f51';
    },
    tileSize: new google.maps.Size(256, 256),
    maxZoom: 21,
    minZoom: 0,
    radius: 6371000,
    name: 'OpenLandscapeMap'
};
var OpenLandscapeMapType = new google.maps.ImageMapType(OpenLandscapeMapTypeOptions);
var OpenStreetMapsOptions = {
    getTileUrl: function(coord, zoom) {
        var normalizedCoord = getNormalizedCoord(coord, zoom);
        if (!normalizedCoord) {
            return null;
        }
        var bound = Math.pow(2, zoom);
        return 'http://tile.openstreetmap.org/' + zoom + '/' + normalizedCoord.x + '/' + normalizedCoord.y + '.png';
    },
    tileSize: new google.maps.Size(256, 256),
    maxZoom: 21,
    minZoom: 0,
    radius: 6371000,
    name: 'OpenStreetMaps'
};
var OpenStreetMapsType = new google.maps.ImageMapType(OpenStreetMapsOptions);
var OpenOutdoorsMapTypeOptions = {
    getTileUrl: function(coord, zoom) {
        var normalizedCoord = getNormalizedCoord(coord, zoom);
        if (!normalizedCoord) {
            return null;
        }
        var bound = Math.pow(2, zoom);
        return 'http://tile.thunderforest.com/outdoors' +
            '/' + zoom + '/' + normalizedCoord.x + '/' + normalizedCoord.y + '.png'  + '?apikey=16ee5a6bac6f4f58860ec7cda4bb0f51';
    },
    tileSize: new google.maps.Size(256, 256),
    maxZoom: 21,
    minZoom: 0,
    radius: 6371000,
    name: 'OpenOutdoorsMap'
};
var OpenOutdoorsMapType = new google.maps.ImageMapType(OpenOutdoorsMapTypeOptions);
//Rotating mesages
var rotateIndex = -1;
var rotatingMessages = new Array;
var rotatingMessage;
var iAmRotating = false;
//...................................................................
function initialize() {
    BBgo();
    var currentURL = location.href;
    var query="";
    if(currentURL.indexOf("?")>=0)
        query = currentURL.slice(currentURL.indexOf("?"),currentURL.length);
    else
        query = "";
    var currentTime = new Date();
    var year = currentTime.getFullYear();
    document.getElementById("crYear").innerHTML = year;

    //Google geocoder
    geocoder = new google.maps.Geocoder();
    // Create an ElevationService.
    elevator = new google.maps.ElevationService();
    baseSet = false;
    //Permalinks always win, so check them first.
    if(query.length>0)checkForPermalink(currentURL);
    //But, maybe you don't have a permalink.  Actually, that's the usual case.  So now check for cookies.
    if(!baseSet)checkForCookies();
    getLength();
    travelMode = document.getElementById("travelMode").value;
    var Lat,Lng;
    if(baseSet){
        Lat = BaseLocation.lat();
        Lng = BaseLocation.lng();
    }
    else{
        Lat = 40.735383;
        Lng = -73.984655;
    }
    var initialLocation = new google.maps.LatLng(Lat,Lng);
    //Create the map
    var mapTypeControlOpts = {
        mapTypeIds: [google.maps.MapTypeId.ROADMAP,
            google.maps.MapTypeId.HYBRID,
            google.maps.MapTypeId.SATELLITE,
            google.maps.MapTypeId.TERRAIN,
            'OpenCycleMap',
            'OpenStreetMaps',
            'OpenTransportMap',
            'OpenLandscapeMap',
            'OpenOutdoorsMap'
        ],
        position: google.maps.ControlPosition.TOP_RIGHT,
        style: google.maps.MapTypeControlStyle.DEFAULT
    };
    var rotateControlOpts = {
        position: google.maps.ControlPosition.TOP_CENTER
    };
    var myOptions = {
        zoom: 2,
        tilt: 45,
        scaleControl: true,
        rotateControl: true,
        rotateControlOptions: rotateControlOpts,
        mapTypeControl: true,
        mapTypeControlOptions: mapTypeControlOpts,
        mapTypeId: google.maps.MapTypeId.ROADMAP,
        center: initialLocation,
        disableDoubleClickZoom: true
    };
    map = new google.maps.Map(document.getElementById("map_canvas"), myOptions);
    map.mapTypes.set('OpenStreetMaps', OpenStreetMapsType);
    map.mapTypes.set('OpenTransportMap', OpenTransportMapType);
    map.mapTypes.set('OpenLandscapeMap', OpenLandscapeMapType);
    map.mapTypes.set('OpenCycleMap', OpenCycleMapType);
    map.mapTypes.set('OpenOutdoorsMap', OpenOutdoorsMapType);

    directionsDisplay.setMap(map);
    directionsDisplay.setPanel(document.getElementById("directionsPanel"));  //Turn this on to allow Google to create textual directions
    trafficLayer = new google.maps.TrafficLayer();
    weatherLayer = new google.maps.weather.WeatherLayer({
        temperatureUnits: google.maps.weather.TemperatureUnit.FAHRENHEIT
    });
    weatherLayer.setMap(map);
    cloudLayer = new google.maps.weather.CloudLayer();
    cloudLayer.setMap(map);
    // Instantiate an info window to hold step text.
    stepDisplay = new google.maps.InfoWindow({pixelOffset:{width:00, height:-30} });

    //Listeners, various
    // This Listener catches it if the user drags the route, or changes it in any way.
    google.maps.event.addListener(directionsDisplay, 'directions_changed', function() {
        routeResult = directionsDisplay.directions;
        computeTotalDistance(routeResult);
        buildDirections(routeResult);
        storeRouteData();
    });

    // This Listener catches it if the user double clicks to create a new starting location.
    google.maps.event.addListener(map, "dblclick", function(mEvent) {
        BaseLocation = mEvent.latLng;
        document.getElementById("address").value = BaseLocation.toString();
        createBaseMarker();
        codeAddress();
        calcRoute();
    });

    // Add a listener for right-click, used to remove a waypoint.
    /*    google.maps.event.addListener(map, "rightclick", function (mEvent) {
            var close = 0;
            var test = 0;
            var kill = 0;
            close = LatLngDist(mEvent.latLng.lat(),mEvent.latLng.lng(),
                directionsDisplay.directions.routes[0].legs[0].via_waypoint[0].location.lat(),
                directionsDisplay.directions.routes[0].legs[0].via_waypoint[0].location.lng());
            for(var i=1;i<directionsDisplay.directions.routes[0].legs[0].via_waypoint.length;i++) {
                test = LatLngDist(mEvent.latLng.lat(),mEvent.latLng.lng(),
                    directionsDisplay.directions.routes[0].legs[0].via_waypoint[i].location.lat(),
                    directionsDisplay.directions.routes[0].legs[0].via_waypoint[i].location.lng());
                if(test<close) {
                    close = test;
                    kill = i;
                }
            }
            var answer = confirm("The waypoint to be removed is at " + directionsDisplay.directions.routes[0].legs[0].via_waypoint[kill].location.toString());
            if(answer) {
                directionsDisplay.directions.routes[0].legs[0].via_waypoint.splice(kill,1);
                rlPoints = new Array();
                for(var i=0;i<directionsDisplay.directions.routes[0].legs[0].via_waypoint.length;i++) {
                    rlPoints[i] = directionsDisplay.directions.routes[0].legs[0].via_waypoint[i].location;
                } calcRoute();
            }
        });*/
    if(baseSet){
        createBaseMarker();
        codeAddress();
    }
    //Initialize permalinks
    var permalink;
    var protocol = location.protocol;
    var host = location.host;
    var path = location.pathname;
    permalink = protocol+"//"+host+path;
    document.getElementById("permalink").href = permalink;
    //Also, make one that will take you back over to Google Maps.
    permalink = protocol+"//"+host+"/OSM";
    document.getElementById("OSMversion").href = permalink;
    if(query.length>0 && baseSet)calcRoute(); //So, if you came in with a permalink, create the route.
}
//..................................................................................................
//Function for overlaying tile types.
// Normalizes the coords that tiles repeat across the x axis (horizontally)
// like the standard Google map tiles.
function getNormalizedCoord(coord, zoom) {
    var y = coord.y;
    var x = coord.x;
    // tile range in one direction range is dependent on zoom level
    // 0 = 1 tile, 1 = 2 tiles, 2 = 4 tiles, 3 = 8 tiles, etc
    var tileRange = 1 << zoom;
    // don't repeat across y-axis (vertically)
    if (y < 0 || y >= tileRange) {
        return null;
    }
    // repeat across x-axis
    if (x < 0 || x >= tileRange) {
        x = (x % tileRange + tileRange) % tileRange;
    } return {
        x: x,
        y: y
    };
}
//......................................................................................
function checkForPermalink(currentURL) {
    //Quick check for a URL intended to enable routeloops from the Chrome search bar.
    var split1 = currentURL.split('?');
    var qs = split1[1];
    var split2 = qs.split('&');

    if(split2.length==2){
        var result = {};
        for (var i=0;i<split2.length;i++){
            var split3 = split2[i].split('=');
            if(split3[0] == 'address')  result.address = split3[1];
            if(split3[0] == 'distance')  result.distance = split3[1];
        }
        if(result.address && result.distance){
            baseSet = true;
            document.getElementById('address').value = result.address;
            document.getElementById('length').value = result.distance;
            codeAddress()
                .then(function(){
                    redrawOrNew(-1);
                })
                .then(null,function(err){
                    console.log('Some sort of problem in using the quick URL.... ' + err)
                });
        }
    } else{
        if(parseUrl(currentURL)) //There is a valid permalink in this URL, so use it.
        {
            if(uBase)document.getElementById("address").value = uBase.lat() +","+ uBase.lng();
            BaseLocation = new google.maps.LatLng(uBase.lat(),uBase.lng());
            baseSet = true;
            for(var i=0;i<urlPoints.length;i++)
                rlPoints[i] = new google.maps.LatLng(urlPoints[i].lat(),urlPoints[i].lng());
            travelMode = utM;
            document.getElementById("travelMode").value = utM;
            if(uuS==0)
                document.getElementById("length").value = ulen;
            else if(uuS==1)
                document.getElementById("length").value = (ulen*KM2MILES).toFixed(2);
            if(!uClean){
                DoClean=true;  //make sure it's on, and then...
                toggleAutoClean();  //shut it off.
            }
            else if(uClean){
                DoClean=false;  //make sure it's off, and then...
                toggleAutoClean();  //turn it on.
            }
        }
        else {
            if(haveOldUrl) {
                document.getElementById("address").value = oldUrlLat +","+ oldUrlLng;
                BaseLocation = new google.maps.LatLng(oldUrlLat,oldUrlLng);
                baseSet = true;
            }
            if(haveEmbedded) {
                //alert("Have an embedded URL");
                parsedUrl = true;
                //calcRoute();
            }
        }
    } return;
}
//......................................................................................
function checkForCookies() {
    //Check to see if we have any cookie information to start with
    var CookieLength  = readCookie("length");
    if(CookieLength!=null)document.getElementById("length").value = CookieLength;
    var CookieTM      = readCookie("TM");
    if(CookieTM!=null)document.getElementById("travelMode").value = parseInt(CookieTM);
    // var CookieTD      = readCookie("TD");
    // if(CookieTD!=null)document.getElementById("travelDirection").value = parseInt(CookieTD);
    var CookieUS      = readCookie("US");
    if(CookieUS!=null)document.getElementById("unitSystem").value = parseInt(CookieUS);
    var CookieClean   = readCookie("Clean");
    var CookieAddress = readCookie("address");
    if(CookieAddress!=null) {
        document.getElementById("address").value = CookieAddress;
        $("#address").removeClass("watermark"); //remove class when user focus on the textbox
        codeAddress();
        if(CookieClean == "Turn AutoClean On")toggleAutoClean();
    }
    if(document.getElementById("unitSystem").value == 0) {
        document.getElementById("total_1").innerHTML = "0 miles";
        document.getElementById("inputUnits").innerHTML = "miles";
        document.getElementById("tcxUnits").innerHTML = "feet";
        document.getElementById("tcxSpeedUnits").innerHTML = "mph";
    } else {
        document.getElementById("total_1").innerHTML = "0 kilometers";
        document.getElementById("inputUnits").innerHTML = "kilometers";
        document.getElementById("tcxUnits").innerHTML = "meters";
        document.getElementById("tcxSpeedUnits").innerHTML = "kph";
    } return;
}
//......................................................................................
function codeAddress() {
    return new Promise(function(resolve,reject){
        var address = document.getElementById("address").value;
        geocoder.geocode( { 'address': address}, function(results, status) {
            if (status == google.maps.GeocoderStatus.OK) {
                if(BaseMarker)BaseMarker.setMap(null);
                BaseLocation = results[0].geometry.location;
                BaseMarker = placeMarker(BaseLocation,'Home - Start/Stop');
                map.setCenter(BaseLocation);
                BaseMarker.setZIndex(1000);
                BaseMarker.setTitle("Start/Stop @ " + results[0].formatted_address);
                document.getElementById("address").value = results[0].formatted_address;
                if(BaseMarkerAction)google.maps.event.removeListener(BaseMarkerAction);
                BaseMarkerAction = google.maps.event.addListener(BaseMarker,'dragend',function(mEvent){
                    BaseLocation = mEvent.latLng;
                    document.getElementById("address").value = mEvent.latLng.toString();
                    codeAddress();
                });
                if(map.getZoom()==2)map.setZoom(11);
                baseSet = true;
                var list = results[0].address_components.length;
                for(var i=0;i<list;i++) {
                    if(results[0].address_components[i].types=="country,political")Country=results[0].address_components[i].long_name;
                }
                if (Language=="EN")
                    document.getElementById("GoButton").innerHTML="Create a Route of this Length";
                resolve(results[0]);
            } else {
                //alert("Geocode was not successful for the following reason: " + status);
                alert("Geocode returned: " + status + "\n Please make sure you have an address in the address field.");
                reject("Some kind of geocoding error");
            }
        });
    }); return;
}
//........................................................................
function getRLpoints() {
    for(var i=0;i<importedTracks.length;i++)
        if(importedTracks[i])importedTracks[i].setMap(null);
    historyPointer = resultHistory.length;
    storeInHistory=true;
    if(pitchMarker)pitchMarker.setMap(null);
    if(fixedPoints.length>0)
        fixedPointRoute(targetLengthInMeters);
    else {
        //Pick one of the methods for generating the points.
        var pickMethod = Math.floor(3*Math.random());
        if(pickMethod==0) {
            //alert("Circle route while pickOne = " + pickOne);
            circleRoute(targetLengthInMeters);
        }
        if(pickMethod==1) {
            //alert("Rectangle route while pickOne = " + pickOne);
            rectangleRoute(targetLengthInMeters);
        }
        if(pickMethod==2) {
            //alert("Figure 8 route while pickOne = " + pickOne);
            fig8Route(targetLengthInMeters);
        }
    } return;
}
//.....................................................................................
function calcRoute() {
    if(rlPoints.length==0)return;  //There is no reason to be here, yet.  You might have gotten here because people were changing Settings.
    countCalcs++;
    if(document.getElementById("unitSystem").value == 0)
        var units = google.maps.DirectionsUnitSystem.IMPERIAL;
    else if(document.getElementById("unitSystem").value == 1)
        var units = google.maps.DirectionsUnitSystem.METRIC;
    var wpts = [];
    for (var i=0;i<rlPoints.length;i++) {
        wpts.push({
            location:rlPoints[i],
            stopover:false});
    }
    //alert("Wpts length is :"+wpts.length);
    travelMode = document.getElementById("travelMode").value;
    travelDirection = document.getElementById("travelDirection").value;
    travelHeading = document.getElementById("travelHeading").value;
    var gTravelMode;
    if(travelMode==0)gTravelMode=google.maps.DirectionsTravelMode.DRIVING;
    else if(travelMode==1)gTravelMode=google.maps.DirectionsTravelMode.BICYCLING;
    else if(travelMode==2)gTravelMode=google.maps.DirectionsTravelMode.WALKING;

    // Keep a record of the requests that are made.
    var storage;
    storage = "Base="+BaseLocation.lat()+":"+BaseLocation.lng();
    storage = storage + "&tM=" + travelMode;
    storage = storage + "&len=" + document.getElementById("length").value;
    storage = storage + "&unitS=" + document.getElementById("unitSystem").value;
    storage = storage + "&address=" + document.getElementById("address").value;
    storage = storage + "&function=calcRoute";
    //$.post("write_data.php?"+storage);
    var fromHere = BaseLocation;
    var toHere = BaseLocation;

    var request = {
        origin: fromHere,
        destination: toHere,
        waypoints: wpts,
        travelMode: gTravelMode,
        avoidHighways: avoidHighways,
        unitSystem: units
    };
    directionsService.route(request, examineRoute);
    return;
}
//.....................................................................................
function examineRoute(response,status) {
    var thisRoute = response.routes[0].legs[0];
    routeLatLng.length=0;
    var step = response.routes[0].legs[0].steps.length;
    for(var i=0;i<thisRoute.steps.length;i++) {
        var path = thisRoute.steps[i].path;
        for(var j=0;j<path.length;j++) {
            if(i>0 && j==0)continue; //Do not write this point since it is also the end of the last leg.
            var lat = thisRoute.steps[i].path[j].lat();
            var lng = thisRoute.steps[i].path[j].lng();
            var loc = new google.maps.LatLng(lat,lng);
            routeLatLng.push({location:loc,narrative:""});
        }
    }
    var removedPoints;
    if(DoClean) removedPoints = cleanTails(response);
    else if(!DoClean)removedPoints = -1;
    if(removedPoints>0 && removedPoints!=lastRemoved) {
        lastRemoved=removedPoints;
        $('#progress').remove();
        calcRoute();
    } else {
        $('#progress').remove();
        computeTotalDistance(response);
        if(!compareToPlan(response)) {
            getRLpoints();
            calcRoute();
        }
        //OK, this is a good one.
        countCalcs = 0;
        adjustScale();
        routeResult = response;
        showSteps(response);
        directionsDisplay.setDirections(response);
        if(storeInHistory)makeHistory(response);
        if(response.routes[0].warnings.length>0)
            document.getElementById("modeWarning").innerHTML = "<b><i>"+response.routes[0].warnings[0]+"</i></b>";
        else
            document.getElementById("modeWarning").innerHTML = "";
        storeRouteData();
        makePermalink();
        writeCookies();

        document.getElementById("GoButton").innerHTML="Create a Different Route<br/>of the Same Length";
    } return;
}
//...............................................................................................
function computeTotalDistance(result) {
    var total = 0;
    var timeTot;
    var timeH=0;
    var timeM=0;
    var timeText;
    var speed = parseFloat(document.getElementById("tcxSpeed").value);
    var myroute = result.routes[0];
    for (i = 0; i < myroute.legs.length; i++) {
        total += myroute.legs[i].distance.value;
    }
    //total is currently in meters.
    if(document.getElementById("unitSystem").value == 0) {
        total = total *100 /2.54 /12 /5280;
        //document.getElementById("total_2").innerHTML = total.toPrecision(7) + " miles";
        var tP = Math.log(total)/Math.log(10);
        tP = Math.floor(tP);
        tP += 3;
        document.getElementById("total_1").innerHTML = total.toPrecision(tP) + " miles";
        totalDistanceInCurrentUnits = total;
        localStorage.setItem("distance", totalDistanceInCurrentUnits);
    } else {
        total = total /1000;
        //document.getElementById("total_2").innerHTML = total.toPrecision(7) + " kilometers";
        var tP = Math.log(total)/Math.log(10);
        tP = Math.floor(tP);
        tP += 3;
        document.getElementById("total_1").innerHTML = total.toPrecision(tP) + " kilometers";
        totalDistanceInCurrentUnits = total;
        localStorage.setItem("distance", totalDistanceInCurrentUnits);
    }
    timeTot = total/speed *60 *60; //time in seconds
    timeH = hours(timeTot);
    timeM = minutes(timeTot);
    if(timeH>0)timeText = timeH + " hours ";
    else timeText = "";
    if(timeM>0)timeText += timeM + " min ";
    else timeText += "";
    document.getElementById("routeTime").innerHTML = timeText;
    return;
}
//....................................................................................................................
function changeSpeed() {
    var total = totalDistanceInCurrentUnits;
    var timeTot;
    var timeH=0;
    var timeM=0;
    var timeText;
    var speed = parseFloat(document.getElementById("tcxSpeed").value);
    timeTot = total/speed *60 *60; //time in seconds
    timeH = hours(timeTot);
    timeM = minutes(timeTot);
    if(timeH>0)timeText = timeH + " hours ";
    else timeText = "";
    if(timeM>0)timeText += timeM + " min ";
    else timeText += "";
    document.getElementById("routeTime").innerHTML = timeText;
    return;
}
//....................................................................................................................
function fixedPointRoute(length) {
    //How far is it to your fixed point?
    var distToFixed = computeDistanceBetween(BaseLocation,fixedPoints[0].marker.getPosition());
    if(distToFixed/requestedLengthInMeters > 0.5) {
        alert("The distance requested is less than half the straight line distance to the fixed waypoint.  No way to close a route.");
    }
    else {
        var brngToFixed = getBearing(BaseLocation,fixedPoints[0].marker.getPosition());
        /* Now, choose a direction in which to head, and go the distance such that the sum of the 3 legs
	 (base to fixed, fixed to next, next to base) add up to the desired distance, length. */
        var minTurn = 20;  var maxTurn = 160;
        var direction = Math.random()* (maxTurn-minTurn) + minTurn;
        var side = Math.floor(2*Math.random());
        if(side==0) direction = direction;
        if(side==1) direction = -1* direction;
        var newBearing = brngToFixed + direction * Math.PI/180;
        var step = 0;
        var toHere;
        var allLegs = 0;
        while(allLegs < length) {
            step += 1;  //Move out in steps of 1 meter.
            toHere = getNewPointAlongBearing(fixedPoints[0].marker.getPosition(),step,newBearing);
            allLegs = distToFixed + computeDistanceBetween(fixedPoints[0].marker.getPosition(),toHere) + computeDistanceBetween(toHere,BaseLocation);
        }
        var newBearing2 = newBearing + (1-side*2)*5*Math.PI/180;
        var toHere2 = getNewPointAlongBearing(fixedPoints[0].marker.getPosition(),step,newBearing2);
        rlPoints.length=0;
        rlPoints.push(fixedPoints[0].marker.getPosition());
        rlPoints.push(toHere);
        rlPoints.push(toHere2);
    } return;
}
//....................................................................................................................
function circleRoute(length) {
    //alert("Doing a circular route");
    var radius = length/2/Math.PI;
    //log ("The radius of the circle is " + radius);
    var circlePoints = 4;
    var deg = [];
    //Choose a direction for this value
    if(travelHeading==0)
        var direction = Math.random()*2*Math.PI;  //in radians
    else if(travelHeading==1) //this is North
        var direction = Math.random()*Math.PI/4 + 3*Math.PI/8;
    else if(travelHeading==2) //this is Northeast
        var direction = Math.random()*Math.PI/4 + 1*Math.PI/8;
    else if(travelHeading==3) //this is East
        var direction = Math.random()*Math.PI/4 - Math.PI/8;
    else if(travelHeading==4) //this is Southeast
        var direction = Math.random()*Math.PI/4 + 13*Math.PI/8;
    else if(travelHeading==5) //this is South
        var direction = Math.random()*Math.PI/4 + 11*Math.PI/8;
    else if(travelHeading==6) //this is Southwest
        var direction = Math.random()*Math.PI/4 + 9*Math.PI/8;
    else if(travelHeading==7) //this is West
        var direction = Math.random()*Math.PI/4 + 7*Math.PI/8;
    else if(travelHeading==8) //this is Northwest
        var direction = Math.random()*Math.PI/4 + 5*Math.PI/8;

    //Locate the point that is radius meters away from the Base Location in the direction chosen.
    //length assumed in meters, and then deltas in degrees.
    var dx = radius*Math.cos(direction);
    var dy = radius*Math.sin(direction);
    var delta_lat = dy/110540;
    var delta_lng = dx/(111320*Math.cos(BaseLocation.lat()*Math.PI/180));
    center = new google.maps.LatLng(BaseLocation.lat()+delta_lat,BaseLocation.lng()+delta_lng);

    //Find circlePoints other points to use
    //First, call the initial direction direction+180, since we are looking in the opposite direction.
    deg[0] = direction + Math.PI;
    if(travelDirection==0)//Clockwise
        var sign = -1;
    else
        var sign = +1;
    for(var i=1;i<circlePoints+1;i++) {
        deg[i] = deg[i-1] + sign*2*Math.PI/(circlePoints+1);
        dx = radius*Math.cos(deg[i]);
        dy = radius*Math.sin(deg[i]);
        delta_lat = dy/110540;
        delta_lng = dx/(111320*Math.cos(center.lat()*Math.PI/180));
        rlPoints[i-1] = new google.maps.LatLng(center.lat()+delta_lat,center.lng()+delta_lng);
        //placeMarker(pts[i-1],'p'+i);
    }
}
//.........................................................................................
function rectangleRoute(length) {
    //alert("Doing a rectangular route");
    var direction = 0;
    var angle = 0;
    rlPoints.length = 0;
    //Choose a ratio of height to width.  This may be more complex than necessary, but what the heck.
    var maxRatio = 5;
    var minRatio = 1./maxRatio;
    var deltaRatio = maxRatio - minRatio;
    var ratio = Math.random()*deltaRatio + minRatio;
    //alert("Ratio for this box is " + ratio);
    //var ratio = 2;
    var width = length/(2*ratio+2);
    var height = width*ratio;
    var diagonal = Math.sqrt(width*width + height*height);
    var theta = Math.acos(height/diagonal);
    //Choose a direction for this value
    if(travelHeading==0)
        var direction = Math.random()*2*Math.PI;  //in radians
    else if(travelHeading==1) //this is North
        var direction = Math.random()*Math.PI/4 + 3*Math.PI/8;
    else if(travelHeading==2) //this is Northeast
        var direction = Math.random()*Math.PI/4 + 1*Math.PI/8;
    else if(travelHeading==3) //this is East
        var direction = Math.random()*Math.PI/4 - Math.PI/8;
    else if(travelHeading==4) //this is Southeast
        var direction = Math.random()*Math.PI/4 + 13*Math.PI/8;
    else if(travelHeading==5) //this is South
        var direction = Math.random()*Math.PI/4 + 11*Math.PI/8;
    else if(travelHeading==6) //this is Southwest
        var direction = Math.random()*Math.PI/4 + 9*Math.PI/8;
    else if(travelHeading==7) //this is West
        var direction = Math.random()*Math.PI/4 + 7*Math.PI/8;
    else if(travelHeading==8) //this is Northwest
        var direction = Math.random()*Math.PI/4 + 5*Math.PI/8;
    //log("The direction of this point with be at " + direction*180/Math.PI + " degrees.");
    if(travelDirection==0)//Clockwise
        var sign = -1;
    else
        var sign = +1;

    //There are 3 points to locate.  Easiest in this case to do each separately.
    //Locate the point that is radius meters away from the Base Location in the direction chosen.
    //length assumed in meters, and then deltas in degrees.
    angle = 0+direction; // This is defined to be the point along the "height" direction
    var dx = height*Math.cos(angle);
    var dy = height*Math.sin(angle);
    var delta_lat = dy/110540;
    var delta_lng = dx/(111320*Math.cos(BaseLocation.lat()*Math.PI/180));
    rlPoints[0] = new google.maps.LatLng(BaseLocation.lat()+delta_lat,BaseLocation.lng()+delta_lng);
    //alert(" The first corner point will be at " + p1);
    //placeMarker(p1,'h corner');

    angle = sign*theta+direction; // This is defined to be the point along the "diagonal" direction
    var dx = diagonal*Math.cos(angle);
    var dy = diagonal*Math.sin(angle);
    var delta_lat = dy/110540;
    var delta_lng = dx/(111320*Math.cos(BaseLocation.lat()*Math.PI/180));
    rlPoints[1] = new google.maps.LatLng(BaseLocation.lat()+delta_lat,BaseLocation.lng()+delta_lng);
    //alert(" The second corner point will be at " + p2);
    //placeMarker(p2,'d corner');
    angle = sign*Math.PI/2+direction; // This is defined to be the point along the "width" direction
    var dx = width*Math.cos(angle);
    var dy = width*Math.sin(angle);
    var delta_lat = dy/110540;
    var delta_lng = dx/(111320*Math.cos(BaseLocation.lat()*Math.PI/180));
    rlPoints[2] = new google.maps.LatLng(BaseLocation.lat()+delta_lat,BaseLocation.lng()+delta_lng);
    //alert(" The second corner point will be at " + p3);
    //placeMarker(p3,'w corner');
    return;
}
//.............................................................
function fig8Route(length) {
    /*
  The figure 8 will be done as 2 circles, each of half the desired length.
  */
    //alert("Doing a figure 8 route");
    //FIRST CIRCLE
    var radius = length/4/Math.PI;
    //log ("The radius of the first circle is " + radius);
    var circlePoints = 3;
    var deg = [];
    var rlpCount;

    //Choose a direction for this value.  Kind of weird with the figure 8, but let's let it be for now.
    if(travelHeading==0)
        var direction = Math.random()*2*Math.PI;  //in radians
    else if(travelHeading==1) //this is North
        var direction = Math.random()*Math.PI/4 + 3*Math.PI/8;
    else if(travelHeading==2) //this is Northeast
        var direction = Math.random()*Math.PI/4 + 1*Math.PI/8;
    else if(travelHeading==3) //this is East
        var direction = Math.random()*Math.PI/4 - Math.PI/8;
    else if(travelHeading==4) //this is Southeast
        var direction = Math.random()*Math.PI/4 + 13*Math.PI/8;
    else if(travelHeading==5) //this is South
        var direction = Math.random()*Math.PI/4 + 11*Math.PI/8;
    else if(travelHeading==6) //this is Southwest
        var direction = Math.random()*Math.PI/4 + 9*Math.PI/8;
    else if(travelHeading==7) //this is West
        var direction = Math.random()*Math.PI/4 + 7*Math.PI/8;
    else if(travelHeading==8) //this is Northwest
        var direction = Math.random()*Math.PI/4 + 5*Math.PI/8;
    //log("The direction of the first figure 8 point with be at " + direction*180/Math.PI + " degrees.");

    //Locate the point that is radius meters away from the Base Location in the direction chosen.
    //length assumed in meters, and then deltas in degrees.
    var dx = radius*Math.cos(direction);
    var dy = radius*Math.sin(direction);
    var delta_lat = dy/110540;
    var delta_lng = dx/(111320*Math.cos(BaseLocation.lat()*Math.PI/180));
    center = new google.maps.LatLng(BaseLocation.lat()+delta_lat,BaseLocation.lng()+delta_lng);
    //log(" The first figure 8 center point will be at " + center);
    //placeMarker(center,'Circle Center');

    //Find circlePoints other points to use
    //First, call the initial direction direction+180, since we are looking in the opposite direction.
    deg[0] = direction + Math.PI;
    if(travelDirection==0)//Clockwise
        var sign = -1;
    else
        var sign = +1;
    rlpCount=0;
    for(var i=1;i<circlePoints+1;i++) {
        deg[i] = deg[i-1] + sign*2*Math.PI/(circlePoints+1);
        dx = radius*Math.cos(deg[i]);
        dy = radius*Math.sin(deg[i]);
        delta_lat = dy/110540;
        delta_lng = dx/(111320*Math.cos(center.lat()*Math.PI/180));
        rlPoints[rlpCount] = new google.maps.LatLng(center.lat()+delta_lat,center.lng()+delta_lng);
        rlpCount++;
        //placeMarker(pts[i-1],'p'+i);
    }

    //At this point you have circlePoints points in the first circle.  Now do the other side of the figure 8.
    //Choose the exact opposite direction.
    direction = direction + Math.PI;
    //log("The direction of the second figure 8 point with be at " + direction*180/Math.PI + " degrees.");
    //Locate the point that is radius meters away from the Base Location in this new direction.
    //length assumed in meters, and then deltas in degrees.
    var dx = radius*Math.cos(direction);
    var dy = radius*Math.sin(direction);
    var delta_lat = dy/110540;
    var delta_lng = dx/(111320*Math.cos(BaseLocation.lat()*Math.PI/180));
    center = new google.maps.LatLng(BaseLocation.lat()+delta_lat,BaseLocation.lng()+delta_lng);
    //log(" The second figure 8 center point will be at " + center);
    //placeMarker(center,'Circle Center');
    //Find circlePoints other points to use
    //First, call the initial direction direction+180, since we are looking in the opposite direction.
    deg.length = 0; // Zero out this array and use it over again here.
    deg[0] = direction + Math.PI;
    //This part is a little tricky, but to make a real figure 8 I have to reverse the orientation of turns.  Do it for now.
    for(var i=1;i<circlePoints+1;i++) {
        deg[i] = deg[i-1] + sign*2*Math.PI/(circlePoints+1);
        dx = radius*Math.cos(deg[i]);
        dy = radius*Math.sin(deg[i]);
        delta_lat = dy/110540;
        delta_lng = dx/(111320*Math.cos(center.lat()*Math.PI/180));
        rlPoints[rlpCount] = new google.maps.LatLng(center.lat()+delta_lat,center.lng()+delta_lng);
        rlpCount++;
        //placeMarker(pts[i-1],'p'+i);
    } return;
}
//...............................................................
function LatLngDist(lat1,lon1,lat2,lon2) {
    //Check the distance between these points -- returns a value in km.
    var R = 6371; // km
    var dLat = (lat2-lat1)*Math.PI/180;
    var dLon = (lon2-lon1)*Math.PI/180;
    var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    var d = R * c;
    //log("The separation between these points is " + d);
    return d;
}
//...............................................................
function hours(secs) {
    return Math.floor(Math.max(secs,0)/3600.0);
}
//...............................................................
function minutes(secs) {
    return Math.floor((Math.max(secs,0) % 3600.0)/60.0);
}
//...............................................................
function seconds(secs) {
    return Math.round(Math.max(secs,0) % 60.0);
}
//..................................................................
function padZeros(theNumber, max) {
    var numStr = String(theNumber);
    while ( numStr.length < max) {
        numStr = '0' + numStr;
    } return numStr;
}
//...........................................................................................
function placeMarker(location,text) {
    var marker = new google.maps.Marker({
        position: location,
        draggable: true,
        map: map,
        title: text
    });
    //map.setCenter(location);
    return marker;
}
//............................................................................
function createBaseMarker() {
    //Put down the base marker using the current base location.
    if(BaseMarker)BaseMarker.setMap(null);
    var Address = document.getElementById("address").value;
    BaseMarker = placeBase(BaseLocation,'Start/End at:' + Address);
    BaseMarker.setZIndex(1000);
    BaseMarker.setIcon(homeIcon);
    //lmclmc fix this!
    google.maps.event.removeListener(BaseMarkerAction);
    BaseMarkerAction = google.maps.event.addListener(BaseMarker,'dragend',baseLocation);
    return;
}
//.....................................................................................
function placeBase(location,text) {
    var marker = new google.maps.Marker({
        position:location,
        draggable:true,
        map:map,
        title: text
    }); return marker;
}
//..........................................................................................
function baseLocation(evt) {
    BaseLocation.lat = evt.srcObject.latLng.lat;
    BaseLocation.lng = evt.srcObject.latLng.lng;
    var baseL = BaseLocation.lat + "," + BaseLocation.lng;
    document.getElementById("address").value = baseL;
    revcodeLocation();
    return;
}
//....................................................................
function makeTCX() {
    if(currentRouteData.length<=0){alert("You must have a track before you can create a TCX output file.");return;}
    //Try to make a more elegant version using the currentRouteData array.
    //The big problem is that you do not have lat/lng points where you want them, if you want advance warnings.  So in this version,
    //CREATE those lat/lng points and slip them into the currentRouteDistance array.
    //Make an array of where the turns actually are.
    var actualDistance = [];
    actualDistance.length = 0;
    for (var i=0;i<currentRouteData.length;i++) {
        currentRouteData[i].write = false;  // Clear out all current write instructions so that you don't get multiples.
        if(currentRouteData[i].instructions.length>0) {
            var len = currentRouteData[i].instructions.length;
            if(currentRouteData[i].instructions.charAt(len-1) == "*") {
                currentRouteData[i].instructions.length=0;
                currentRouteData[i].instructions="";
            }
        } if(currentRouteData[i].instructions.length>0)actualDistance.push(currentRouteData[i].dist);
    } var offset = document.getElementById("tcxAdvance").value;
    if(document.getElementById("unitSystem").value==0) //This means Imperial units, so convert to meters
        offset *= 12*2.54/100;
    //alert("The TCX offset value being used in meters is " + offset);
    // Loop through currenRouteData and find the locations of the instructions
    var inum = 0;
    for(var loop=0; loop<currentRouteData.length; loop++) {
        if(currentRouteData[loop].instructions.length>0) {
            if(loop==0 || offset==0) {
                currentRouteData[loop].write = true;
                inum++;
            } else {
                //OK, this is where you have an instruction.
                var insDist = currentRouteData[loop].dist;
                //Now, we WANT to have an instruction before this, so the correct distance for this instruction is
                var corrDist = insDist - offset;
                if(corrDist<0)corrDist = insDist/2; //Bit arbitrary, but need to put the instruction somewhere if there is not offset meters to use, yet.
                //Also, don't let multiple instructions pile up before the actual location itself.  So:
                if(corrDist<actualDistance[inum-1]) {
                    corrDist = actualDistance[inum-1] + (actualDistance[inum]-actualDistance[inum-1])*0.25;
                }
                //OK, so now we have do do two things.  We have to CREATE a new point at this correct distance, and we have to assign the instruction to it.
                for(var i=0;i<currentRouteData.length;i++)
                    if(currentRouteData[i].dist>corrDist)
                        break;
                var j = i;
                i--;
                //OK, we have the points we want to use.  Now interpolate between those points.
                //Lots of good material at http://www.movable-type.co.uk/scripts/latlong.html.
                var distToGo = corrDist - currentRouteData[i].dist;
                var Lat1 = currentRouteData[i].lat;var lat1 = Lat1*Math.PI/180;
                var Lon1 = currentRouteData[i].lng;var lon1 = Lon1*Math.PI/180;
                var Lat2 = currentRouteData[j].lat;var lat2 = Lat2*Math.PI/180;
                var Lon2 = currentRouteData[j].lng;var lon2 = Lon2*Math.PI/180;
                var R = 6371; // km
                var dLat = (lat2-lat1);
                var dLon = (lon2-lon1);

                //Get the bearing
                var y = Math.sin(dLon) * Math.cos(lat2);
                var x = Math.cos(lat1)*Math.sin(lat2) -
                    Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
                var brng = Math.atan2(y, x);

                //Now get the destination, given the starting point and the bearing
                var d = distToGo/1000;  //in km.
                var lat3 = Math.asin( Math.sin(lat1)*Math.cos(d/R) +
                    Math.cos(lat1)*Math.sin(d/R)*Math.cos(brng) );
                var lon3 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(d/R)*Math.cos(lat1),
                    Math.cos(d/R)-Math.sin(lat1)*Math.sin(lat3));
                var Lat3 = lat3*180/Math.PI;
                var Lon3 = lon3*180/Math.PI;

                //OK, so we have the new location.  Now we want to slip it into the array at the right point.
                var txt = currentRouteData[loop].instructions + "*";
                var temp = new routeData(Lat3,Lon3,corrDist,0,0,false,false,txt,true);
                currentRouteData.splice(i+1,0,temp);
                //And now that you have added an element to the array, push the loop along by one so that you don't process this instruction again.
                loop++;
                inum++;
            }
        }
    }
    //Figure out the speed
    var Dist = routeResult.routes[0].legs[0].distance.value;
    if(document.getElementById("unitSystem").value == 0) {
        tcxSpeed = document.getElementById("tcxSpeed").value *(5280*12*2.54/100) /(60*60); //Convert to meters/second
    } else {
        tcxSpeed = document.getElementById("tcxSpeed").value *(1000) /(60*60); //Convert to meters/second
    } if(tcxSpeed!=0) {
        var Velocity = tcxSpeed;
        var Time = Dist/Velocity;
    } else {
        var Time = routeResult.routes[0].legs[0].duration.value;
        var Velocity = Dist/Time; //in meters/second
    }
    //Make an array to hold the time, in seconds, to reach each point.
    var Times = [];
    Time.length = 0;
    for(var i=0;i<currentRouteData.length;i++) {
        Time = currentRouteData[i].dist/Velocity;
        Time = Math.round(Time); //Get rid of fractional seconds because they can lead to odd times, like 3 minutes and 60 seconds.
        Times.push(Time);
        if(Times[Times.length-1]==Times[Times.length-2])Times[Time.length-1]++; //Move it up by at least one second.
    }
    var currentTime = new Date();
    var year = currentTime.getFullYear();
    var month = currentTime.getMonth() + 1;
    var day = currentTime.getDate();
    var hour = currentTime.getHours();
    var minute = currentTime.getMinutes();
    var name = "RL-" + year + "-" + padZeros(month,2) + "-" + padZeros(day,2) + "-" + padZeros(hour,2) + padZeros(minute,2);
    if(document.getElementById("tcxName").value=="")document.getElementById("tcxName").value = name;
    else name = document.getElementById("tcxName").value;
    var ymd = year + "-" + padZeros(month,2) + "-" + padZeros(day,2);
    //alert ("The name is " + name);
    //var generator=window.open('','TCX','height=500,width=800,resizable=yes,scrollbars=yes,menubar=yes');
    var OutText = "";
    OutText+="<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>\n";
    OutText+="<!--\n";
    OutText+=storeURL()+"\n";
    OutText+="-->\n";
    OutText+="<TrainingCenterDatabase xmlns=\"http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2 http://www.garmin.com/xmlschemas/TrainingCenterDatabasev2.xsd\">\n";
    OutText+="<Courses>\n";
    OutText+="  <Course>\n";
    OutText+="  <Name>"+name+"</Name>\n";
    OutText+="  <Lap>\n";
    OutText+="    <TotalTimeSeconds>" + Time + "</TotalTimeSeconds>\n";
    OutText+="    <DistanceMeters>" + Dist + "</DistanceMeters>\n";
    OutText+="    <BeginPosition>\n";
    var Lat = routeResult.routes[0].legs[0].start_location.lat();
    OutText+="      <LatitudeDegrees>" + Lat + "</LatitudeDegrees>\n";
    var Lng = routeResult.routes[0].legs[0].start_location.lng();
    OutText+="      <LongitudeDegrees>" + Lng + "</LongitudeDegrees>\n";
    OutText+="    </BeginPosition>\n";
    OutText+="    <EndPosition>\n";
    var Lat = routeResult.routes[0].legs[0].start_location.lat();
    OutText+="      <LatitudeDegrees>" + Lat + "</LatitudeDegrees>\n";
    var Lng = routeResult.routes[0].legs[0].start_location.lng();
    OutText+="      <LongitudeDegrees>" + Lng + "</LongitudeDegrees>\n";
    OutText+="    </EndPosition>\n";
    OutText+="    <Intensity>Active</Intensity>\n";
    OutText+="    <Cadence>65</Cadence>\n";
    OutText+="  </Lap>\n";
    OutText+="  <Track>\n";
    var step = currentRouteData.length;

    //Write out all of the Track Points
    for(var i=0;i<step;i++) {
        OutText+="    <Trackpoint>\n";
        OutText+="      <Position>\n";
        var Lat = currentRouteData[i].lat;
        OutText+="        <LatitudeDegrees>" + Lat + "</LatitudeDegrees>\n";
        var Lng = currentRouteData[i].lng;
        OutText+="        <LongitudeDegrees>" + Lng + "</LongitudeDegrees>\n";
        var Dist = currentRouteData[i].dist;
        var Time = Times[i];
        OutText+="      </Position>\n";
        OutText+="      <DistanceMeters>" + Dist.toFixed(0) + "</DistanceMeters>\n";
        OutText+="      <Time>"+ymd+"T"+padZeros(hours(Time).toFixed(0),2)
            +":"+padZeros(minutes(Time).toFixed(0),2)
            +":"+padZeros(seconds(Time).toFixed(0),2)
            +"Z</Time>\n";
        OutText+="    </Trackpoint>\n";
    } OutText+="  </Track>\n";

    //Write out all of the Course Points
    var alerts = markerPosition.length;
    var walk = 0; //This is an index used to walk through the allPoints array to find the next instance of the Lat/Lng where you will write the alert.
    var inum = 0;
    for(var i=0;i<currentRouteData.length;i++) {
        if(currentRouteData[i].write) {
            var instruct = currentRouteData[i].instructions;
            var len = instruct.length;
            if(instruct.charAt(len-1) == "*")instruct=instruct.substring(0,len-1);
            //Figure out the direction
            {
                if(instruct.indexOf("left") >=0 )var type = "Left";
                else if(instruct.indexOf("right") >=0 )var type = "Right";
                else if(instruct.indexOf("Continue") >=0 )var type = "Straight";
                else var type = "Generic";
            }
            // Figure out the road
            {
                if(instruct.indexOf(" at ") >=0 ) {
                    var point = instruct.indexOf(" at ");
                    var road = instruct.substring(point+3);
                } else if(instruct.indexOf(" onto ") >=0 ) {
                    var point = instruct.indexOf(" onto ");
                    var road = instruct.substring(point+5);
                } else if(instruct.indexOf(" on ") >=0 ) {
                    var point = instruct.indexOf(" on ");
                    var road = instruct.substring(point+3);
                }
            }
            var Lat = currentRouteData[i].lat;
            var Lng = currentRouteData[i].lng;
            var Tym=Times[i];
            var CPloc = new google.maps.LatLng(Lat,Lng);
            // This will show you where the warnings should appear on the GPS device (TCX file)
            var marker = new google.maps.Marker({
                position: CPloc,
                map: map,
                visible: false,  //DEBUG this on and off
                icon: 'RLimages/iconb.png',
                draggable: true
            });
            attachInstructionText(marker,inum+": "+instruct);
            inum++;
            //alert("Writing item " + i + " of " + alerts + " which is" + instruct);
            OutText+="  <CoursePoint>\n";
            var roadOut = cleanUp(road);
            OutText+="    <Name>" + roadOut + "</Name>\n";
            OutText+="    <Time>"+ymd+"T"+padZeros(hours(Tym).toFixed(0),2)
                +":"+padZeros(minutes(Tym).toFixed(0),2) +":"+padZeros(seconds(Tym).toFixed(0),2) +"Z</Time>\n";
            OutText+="    <Position>\n";
            OutText+="      <LatitudeDegrees>" + Lat + "</LatitudeDegrees>\n";
            OutText+="      <LongitudeDegrees>" + Lng + "</LongitudeDegrees>\n";
            OutText+="    </Position>\n";
            OutText+="    <PointType>" + type + "</PointType>\n";
            var instructions = cleanUp(currentRouteData[i].instructions);
            OutText+="    <Notes><![CDATA[" + instructions +"]]></Notes>\n";
            OutText+="  </CoursePoint>\n";
        }
    }
    // Crap at the end.  Probably isn't needed.
    OutText+="  <Creator xsi:type=\"Device_t\">\n";
    OutText+="    <Name>EDGE705</Name>\n";
    OutText+="    <UnitId>3670860026</UnitId>\n";
    OutText+="    <ProductID>625</ProductID>\n";
    OutText+="    <Version>\n";
    OutText+="      <VersionMajor>2</VersionMajor>\n";
    OutText+="      <VersionMinor>90</VersionMinor>\n";
    OutText+="      <BuildMajor>0</BuildMajor>\n";
    OutText+="      <BuildMinor>0</BuildMinor>\n";
    OutText+="    </Version>\n";
    OutText+="  </Creator>\n";
    OutText+="</Course>\n";
    OutText+="</Courses>\n";
    OutText+="<Author xsi:type=\"Application_t\">\n";
    OutText+="  <Name>EDGE705</Name>\n";
    OutText+="  <Build>\n";
    OutText+="    <Version>\n";
    OutText+="      <VersionMajor>2</VersionMajor>\n";
    OutText+="      <VersionMinor>90</VersionMinor>\n";
    OutText+="      <BuildMajor>0</BuildMajor>\n";
    OutText+="      <BuildMinor>0</BuildMinor>\n";
    OutText+="    </Version>\n";
    OutText+="    <Type>Release</Type>\n";
    OutText+="  </Build>\n";
    OutText+="  <LangID>EN</LangID>\n";
    OutText+="  <PartNumber>006-B0625-00</PartNumber>\n";
    OutText+="</Author>\n";
    OutText+="</TrainingCenterDatabase>\n";

    var blob = new Blob([OutText], {type: "text/plain;charset=utf-8"});
    saveAs(blob, name+".tcx");
    return;
}
//...............................................................................................
function cleanUp(text) {
    var cleaned;
    cleaned = text;
    if(typeof cleaned=="undefined")cleaned="";
    //Get rid of any HTML tags.
    while(cleaned.indexOf("<") >=0) {
        var from = cleaned.indexOf("<");
        var to = cleaned.indexOf(">");
        var end = from;
        var start = to+1;
        var first = cleaned.slice(0,end);
        var last = cleaned.slice(start,cleaned.length);
        cleaned = first + last;
    }
    //Also there appear to be stars, from time to time.
    while(cleaned.indexOf("*") >=0) {
        var end = cleaned.indexOf("*");
        var first = cleaned.slice(0,end);
        var last = cleaned.slice(end+1,cleaned.length);
        cleaned = first + last;
    } return cleaned;
}
//........................................................................................................................
function showSteps(result) {
    // For each step, place a marker, and add the text to the marker's info window. Also attach the marker to an array so we
    // can keep track of it and remove it when calculating new  routes.
    var myRoute = result.routes[0].legs[0];
    // First, clear out any existing markerArray from previous calculations.
    for (var i = 0; i < markerArray.length; i++) {
        markerArray[i].setMap(null);
    }
    //Locate a point before each direction where you write the direction information.  The
    //point you want to find will be in the path[] array of the previous leg[].
    var offset = document.getElementById("tcxAdvance").value;
    if(document.getElementById("unitSystem").value==0) //This means Imperial units, so convert to meters
        offset *= 12*2.54/100;
    var Time = myRoute.duration.value;
    var Dist = myRoute.distance.value;
    var Velocity = Dist/Time; //in meters/second
    var lastTime;
    markerLabel.length = 0;
    markerArray.length = 0;
    markerPosition.length = 0;
    for (var i=0;i<myRoute.steps.length;i++) {
        //First, put course point warnings directly at the location of those turns, etc.
        latOffset = myRoute.steps[i].path[0].lat();
        lngOffset = myRoute.steps[i].path[0].lng();
        //Next put course point warnings in advance of the next location, if the user has requested it.
        if(offset>0 && i<myRoute.steps.length-1) {
            var next = i+1;
            //Find the first point in this leg which is <'offset' meters before the start of the next leg.
            var latActual = myRoute.steps[next].start_point.lat();
            var lngActual = myRoute.steps[next].start_point.lng();
            var previous = next-1;
            //If there is a leg with only 2 points, we know that the course point will HAVE to be on the first one.
            if(myRoute.steps[previous].path.length==2) {
                var j = 0;
                latOffset = myRoute.steps[previous].path[j].lat();
                lngOffset = myRoute.steps[previous].path[j].lng();
            } else //you have to figure out which is the right point to use.
            {
                for (var j=0;j<myRoute.steps[previous].path.length;j++) {
                    var latOffset = myRoute.steps[previous].path[j].lat();
                    var lngOffset = myRoute.steps[previous].path[j].lng();
                    var sep = LatLngDist(latActual,lngActual,latOffset,lngOffset)*1000;
                    if(sep<offset) {
                        if(j==myRoute.steps[previous].path.length-1) {
                            //alert("Writing the CP warning on the LAST point.");
                            j = myRoute.steps[previous].path.length-2; //move it back by at least 1 point, unless the user clearly wants it at the end.
                            latOffset = myRoute.steps[previous].path[j].lat();
                            lngOffset = myRoute.steps[previous].path[j].lng();
                            sep = LatLngDist(latActual,lngActual,latOffset,lngOffset)*1000;
                        } break;
                    }
                }
                //Since sep is actually < offset, use either this point or the last one, whichever is closest to 'offset'.
                if(j>0) {
                    var XlatOffset = myRoute.steps[previous].path[j-1].lat();
                    var XlngOffset = myRoute.steps[previous].path[j-1].lng();
                    var Xsep = LatLngDist(latActual,lngActual,XlatOffset,XlngOffset)*1000;
                    if(Math.abs(Xsep-offset) < Math.abs(sep-offset)) {
                        latOffset = XlatOffset;
                        lngOffset = XlngOffset;
                        j = j-1;
                    }
                }
            }
            // Now, since you are already putting the directions right at the corners, too, don't allow this part of the code to write
            // at either the beginning, or end, of this path.  Overwriting 2 directions in the same place is not helpful, and Garmin
            // can't handle it at all.  Nothing appears, which is confusing.  So if you ever decide to remove the code where you write on
            // the endpoints you will have to remove this check, but for now...
            if(j!=myRoute.steps[previous].path-1) {
                var markTemp = new google.maps.LatLng(latOffset,lngOffset);
                markerPosition.push(markTemp);
                var marker = new google.maps.Marker({
                    position: markTemp,
                    map: map,
                    visible: false,  //DEBUG this on and off
                    draggable: true
                });
                attachInstructionText(marker, myRoute.steps[next].instructions);
                markerLabel.push(myRoute.steps[next].instructions);
                markerArray.push(marker);
            }
            //A little added bonus.  If you are doing advance warnings and there is a point JUST BEFORE the last point, put a warning there.
            if(j<myRoute.steps[previous].path.length-2  && myRoute.steps[previous].path.length>3) {
                j = myRoute.steps[previous].path.length-2;
                latOffset = myRoute.steps[previous].path[j].lat();
                lngOffset = myRoute.steps[previous].path[j].lng();
                markTemp = new google.maps.LatLng(latOffset,lngOffset);
                markerPosition.push(markTemp);
                var marker = new google.maps.Marker({
                    position: markTemp,
                    map: map,
                    visible: false,  //DEBUG this on and off
                    draggable: true
                });
                attachInstructionText(marker, myRoute.steps[next].instructions);
                markerLabel.push(myRoute.steps[next].instructions);
                markerArray.push(marker);
            }
        }// end loop over whether or not you do advance warnings.
    }// end loop for creating the warnings, advance or not.
    buildDirections(result);
    return;
}
//.......................................................................................................
function reverseOrNew() {
    // This function is used if the user changes the travelDirection parameter.  If there is no path yet, just get points and make route.
    // But if there IS a path, reverse the direction of the waypoints and the just recalculate the route.
    if(rlPoints.length==0) {
        getRLpoints();
        calcRoute();
    }
    else {
        rlPoints.reverse();
        calcRoute();
    }
}
//........................................................................................
function redrawOrNew(flag) {
    // This function is used whenever you want to update things on the map without changing the route. If there is no path yet, just get points and make route..
    // But if there IS a path, load up the waypoints and then just recalculate the route.
    if(flag==-1)rlPoints.length=0;  //If you set the flag to -1, this will create a new route no matter what.
    if(rlPoints.length==0) {
        getRLpoints();
        calcRoute();
    } else {
        calcRoute();
    } return;
}
//..............................................................................................
function toggleAutoClean() {
    if(DoClean) //You are cleaning.  Want to turn it off, and set the button to turn it on.
    {
        DoClean = false;
        /*        if(Language=="JP")
                    document.getElementById("toggleClean").value="オートクリーンをオンにする";
                else if(Language=="FR")
                    document.getElementById("toggleClean").value="Activer AutoClean";
                else*/
        document.getElementById("toggleClean").value="Turn AutoClean On";
        document.getElementById("toggleClean").className="butt3";
    }
    else if(!DoClean) //You are not cleaning.  Want to turn it on, set the button to turn it off.
    {
        DoClean = true;
        /*if(Language=="JP")
            document.getElementById("toggleClean").value="オートクリーンをオフにする";
        else if(Language=="FR")
            document.getElementById("toggleClean").value="Désactiver AutoClean";
        else*/
        document.getElementById("toggleClean").value="Turn AutoClean Off";
        document.getElementById("toggleClean").className="butt1";
    }
    var CookieClean   = document.getElementById("toggleClean").value;
    createCookie("Clean",CookieClean);
}
//.................................................................................................
function dragNoDrag(path) {
    if(path==0){//Lock it.
        directionsDisplay.setOptions({draggable:false});
    } else if(path==1){//Unlock it.
        directionsDisplay.setOptions({draggable:true});
    }
    else if(path==-1){//Switch it.
        var state = directionsDisplay.draggable;
        if(state){//currently draggable.  Make it not.
            document.getElementById('routeDrag').value = "Route Locked. (not draggable)";
            directionsDisplay.setOptions({draggable:false});
        }
        else{//Currently not draggable.  Make it so.
            document.getElementById('routeDrag').value = "Route Unlocked. (draggable)";
            directionsDisplay.setOptions({draggable:true});
        }
    } return;
}
//..................................................................................
function toggleElevation() {
    if(!ePlot) //You are not showing the elevation plot and you want to start
    {
        ePlot = true;
        if(Language=="JP")
            document.getElementById("toggleButton").value="グラフ:オフ";
        else if(Language=="FR")
            document.getElementById("toggleButton").value="Désactiver graphe";
        else
            document.getElementById("toggleButton").value="Turn Plot Off";
        document.getElementById("elevation_chart").style.visibility = "visible";
        document.getElementById("elevation_chart").style.display = "block";
        document.getElementById("ecButton").style.visibility = "visible";
        document.getElementById("ecButton").style.display = "block";
        // Actually generate the plot.
        drawElevationPlot();
    }
    else // You are showing it now, and you want to turn it off.
    {
        ePlot = false;
        if(Language=="JP")
            document.getElementById("toggleButton").value="グラフ:オン";
        else if(Language=="FR")
            document.getElementById("toggleButton").value="Activer graphe";
        else
            document.getElementById("toggleButton").value="Turn Plot On";
        document.getElementById("elevation_chart").style.visibility = "hidden";
        document.getElementById("elevation_chart").style.display = "none";
        document.getElementById("ecButton").style.visibility = "hidden";
        document.getElementById("ecButton").style.display = "none";
    } return;
}
//....................................................................................
function drawElevationPlot() {
    var allPoints = [];
    // Create a new chart in the elevation_chart DIV.
    chart = new google.visualization.ColumnChart(document.getElementById('elevation_chart'));
    var step = routeResult.routes[0].legs[0].steps.length;
    var countPoints = 0;
    for(var i=0;i<step;i++) {
        var path = routeResult.routes[0].legs[0].steps[i].path.length;
        for(var j=0;j<path;j++) {
            if(i>0 && j==0)continue; //Do not write this point since it is also the end of the last leg.
            var Lat = routeResult.routes[0].legs[0].steps[i].path[j].lat();
            var Lng = routeResult.routes[0].legs[0].steps[i].path[j].lng();
            allPoints[countPoints] = new google.maps.LatLng(Lat,Lng);
            countPoints++;
        }
    }
    // Create a PathElevationRequest object using this array.
    // Ask for 256 samples along that path.
    //alert("Making an elevation request of " + allPoints.length + " points.");
    //There is a limitation on the elevation service from google, which says that in each query to the service you
    //can have no more than 1024 requests.  So here we make a thinned out array, rather than using all of allPoints.
    var thinnedArray = [];
    var pointLimit = 250; // Set here the number of points you will pass over to google.
    var ratio = pointLimit/allPoints.length;
    if(ratio>1)ratio=1;
    var track = 0;
    var last = -1;
    for(var i=0;i<allPoints.length;i++) {
        track += ratio;
        if(Math.floor(track) > last) {
            thinnedArray.push(allPoints[i]);
            last = Math.floor(track);
        }
    }
    var pathRequest = {
        'path': thinnedArray,
        'samples': 256
    }
    // Initiate the path request.
    elevator.getElevationAlongPath(pathRequest, plotElevation);
}
//.......................................................................................................
function plotElevation(results, status) {
// Takes an array of ElevationResult objects
// and plots the elevation profile on a Visualization API ColumnChart.

    if (status == google.maps.ElevationStatus.OK) {
        elevations = results;

        // Extract the data from which to populate the chart.
        // Because the samples are equidistant, the 'Sample'
        // column here does double duty as distance along the
        // X axis.

        var units;
        if(document.getElementById("unitSystem").value == 0)units=0;
        else units = 1;
        elevDist.length = 0;
        var data = new google.visualization.DataTable();
        data.addColumn('string', 'Distance');
        data.addColumn('number', 'Elevation');
        for (var i = 0; i < results.length; i++) {
            var scaledDistance = (totalDistanceInCurrentUnits*i/results.length);
            elevDist.push(scaledDistance);
            data.addRow([scaledDistance.toFixed(1).toString(),elevations[i].elevation]);
        }
        // Draw the chart using the data within its DIV.
        document.getElementById('elevation_chart').style.display = 'block';
        document.getElementById('ecButton').style.display = 'block';
        if(units==0)var tx = "Distance (mi)";
        else var tx = "Distance (km)";
        chart.draw(data, {
            width: 640,
            title: 'Move the cursor over the elevation plot to see the location on the route',
            height: 200,
            legend: 'none',
            titleY: 'Elevation (m)',
            titleX: tx
        });
        // Every time the chart fires the "select" event, it should call your
        // myClickHandler() function.
        //google.visualization.events.addListener(chart, 'select', myClickHandler);
        google.visualization.events.addListener(chart, 'onmouseover', myMouseOverHandler);
        google.visualization.events.addListener(chart, 'onmouseout', myMouseOutHandler);
    }
    else {
        alert ("The Elevation Service did not return OK.  Returned: " + status);
    }
}
//...........................................................................................
function myMouseOverHandler(mE) {
    //alert("event " + mE.row);
    if(document.getElementById("unitSystem").value == 0) {
        var Grade;
        if(mE.row>0) {
            var x1 = elevDist[mE.row-1];
            var x2 = elevDist[mE.row];
            var y1 = elevations[mE.row-1].elevation;
            var y2 = elevations[mE.row].elevation;
            x1 *= 5280*12*2.54/100;
            x2 *= 5280*12*2.54/100;
            Grade = (y2-y1)/(x2-x1);
        } else Grade = 0;
        var mText = "Elevation at distance " + elevDist[mE.row].toFixed(1) + " miles is " + elevations[mE.row].elevation.toFixed(1).toString() +
            " meters" + "\n" + "Grade at this point is about " + (Grade*100).toFixed(1) + "%";
    } else {
        var Grade;
        if(mE.row>0) {
            var x1 = elevDist[mE.row-1];
            var x2 = elevDist[mE.row];
            var y1 = elevations[mE.row-1].elevation;
            var y2 = elevations[mE.row].elevation;
            x1 *= 1000;
            x2 *= 1000;
            Grade = (y2-y1)/(x2-x1);
        } else Grade = 0;
        var mText = "Elevation at distance " + elevDist[mE.row].toFixed(1) + " kilometers is " + elevations[mE.row].elevation.toFixed(1).toString() +
            " meters" + "\n" + "Grade at this point is about " + (Grade*100).toFixed(1) + "%";
    }
    stepDisplay.setContent(mText);
    stepDisplay.setPosition(elevations[mE.row].location);
    stepDisplay.open(map);
    bikeMarker = new google.maps.Marker({
        position: elevations[mE.row].location,
        map: map,
        // icon: 'RLimages/OldBike2.png'
    });
}
//..................................................................................................
function myMouseOutHandler(mE) {
    bikeMarker.setMap(null);
}
//..................................................................................................
function placeMileMarkers() {
    var Dist;
    var LastDist;
    var WriteDist;
    var speed = parseFloat(document.getElementById("tcxSpeed").value);
    if(!showingMarkers)  //You are not showing them and you want to.
    {
        showingMarkers = true;
        document.getElementById("toggleMileMarkers").value="Turn distance markers off";
        // First, clear out any existing distance markers from previous maps.
        for (var i = 0; i < mileMarkers.length; i++) {
            mileMarkers[i].marker.setMap(null);
        }
        {
            //Get the current time
            var now = new Date();
            var month = now.getMonth();
            month++;
            var date = now.getDate();
            var hour = now.getHours();
            var minute = now.getMinutes();
            var offset = now.getTimezoneOffset();
        }
        //Set the true ride start time, to get appropriate weather information.
        //Let the user say what time he wants to start.
        //This can be out of the range of the forecast, so you'll have to capture that, but for now just do it.
        var text = month + "/" + date + "," + hour + ":" + minute;
        var startDT = prompt("Choose your starting time for this ride in this format: MM/DD,HH:MM" , text);
        var startD  = startDT.split(",")[0];
        var startMonth = startD.split("/")[0];
        startMonth--;
        var startDate = startD.split("/")[1];
        var startT  = startDT.split(",")[1];
        var startHour = startT.split(":")[0];
        var startMinute = startT.split(":")[1];
        var startTimestamp = new Date(now.getFullYear(), startMonth, startDate, startHour, startMinute, 0, 0);
        rideStart = new Date(startTimestamp);
        var numMM = Math.floor(totalDistanceInCurrentUnits);
        //alert("The number of distance markers will be " + numMM);
        if(numMM>=1)var next = 1;
        var step = routeResult.routes[0].legs[0].steps.length;
        for(var i=0;i<step;i++) {
            var path = routeResult.routes[0].legs[0].steps[i].path.length;
            for(var j=0;j<path;j++) {
                var Lat = routeResult.routes[0].legs[0].steps[i].path[j].lat();
                var Lng = routeResult.routes[0].legs[0].steps[i].path[j].lng();
                if(i==0 && j==0) {
                    Dist = 0;
                } else {
                    var pathlength = LatLngDist(Lat,Lng,Last.lat(),Last.lng()) * 1000;
                    if(document.getElementById("unitSystem").value == 0) {
                        pathlength *= 100/2.54/12/5280;
                    } else if (document.getElementById("unitSystem").value == 1) {
                        pathlength /= 1000;
                    } Dist += pathlength;
                }
                if(Dist>=next) {
                    //Use either this one, or the last one.
                    if(Math.abs(LastDist-next)<Math.abs(Dist-next)) {
                        WriteLat = Last.lat();
                        WriteLng = Last.lng();
                        WriteDist = LastDist;
                    } else {
                        WriteLat = Lat;
                        WriteLng = Lng;
                        WriteDist = Dist;
                    }
                    //alert("Found the Lat Lng for the marker at " + next);
                    var markerPosition = new google.maps.LatLng(WriteLat,WriteLng);
                    if(next<=100) {
                        var marker = new google.maps.Marker({
                            position: markerPosition,
                            map: map,
                            icon: 'RLimages/icong'+next+'.png',
                            shadow: 'RLimages/shadow.png'
                        });
                    } else {
                        var marker = new google.maps.Marker({
                            position: markerPosition,
                            map: map,
                            icon: 'RLimages/icong.png',
                            shadow: 'RLimages/shadow.png'
                        });
                    }
                    var flagText = new String();
                    var secondsToPoint = WriteDist/speed * 60 *60;
                    var atTime = new Date(rideStart);
                    atTime.setSeconds(atTime.getSeconds() + secondsToPoint);
                    if(document.getElementById("unitSystem").value == 0)flagText = next + " mile marker" + "  ("+WriteDist.toFixed(2) + " miles." +")";
                    if(document.getElementById("unitSystem").value == 1)flagText = next + " kilometer marker" + "  ("+WriteDist.toFixed(2) + " km."+")";
                    flagText += "<br/>";
                    flagText += "Estimated time at this point, " + atTime;
                    attachInstructionText(marker,flagText);
                    mileMarkers[next-1] = {marker:marker, timeStamp:atTime, text:flagText};
                    next++;
                }
                var Last = new google.maps.LatLng(Lat,Lng);
                var LastDist = Dist;
            }
        }
    } else if(showingMarkers) //You are showing them, and you want to stop.
    {
        showingMarkers = false;
        document.getElementById("toggleMileMarkers").value="Turn distance markers on";

        // Clear the distance markers.
        for (var i = 0; i < mileMarkers.length; i++) {
            mileMarkers[i].marker.setMap(null);
        }
    }
    //Put weather information based on the expected arrival time at each distance marker.
    if(mileMarkers.length>0) {
        getAndWriteWeatherInfo(0);
    } return;
}
//......................................................................................................
function routeData(lat,lng,dist,height,pitch,peak,trough,instructions,write){
    this.lat = lat;  //degrees
    this.lng = lng;  //degrees
    this.dist = dist; //meters
    this.height = height;   //meters
    this.pitch = pitch;   //number -- this is the slope at any given point
    this.peak = peak;
    this.trough = trough;
    this.instructions = instructions;
    this.write = write;
}
//......................................................................................................
function storeRouteData() {
    currentRouteData.length = 0;
    var thisRoute = routeResult.routes[0].legs[0];
    var step = thisRoute.steps.length;
    for(var i=0;i<step;i++) {
        var path = thisRoute.steps[i].path.length;
        for(var j=0;j<path;j++) {
            var txt = new String();
            if(j==0) {
                txt = thisRoute.steps[i].instructions;
            }
            if(i>0 && j==0) {
                var cRDlen = currentRouteData.length;
                currentRouteData[cRDlen-1].instructions = txt;
                continue; //Do not write a new point since it is also the end of the last leg.  Put the instructions in that location already.
            }
            var Lat = thisRoute.steps[i].path[j].lat();
            var Lng = thisRoute.steps[i].path[j].lng();
            var temp = new routeData(Lat,Lng,0,0,0,false,false,txt,false);
            currentRouteData.push(temp);
        }
    }
    currentRouteData[0].dist = 0;
    var dist = 0;
    for(var i=0;i<currentRouteData.length-1;i++) {
        var j = i+1;
        var distMeters = LatLngDist(currentRouteData[i].lat,currentRouteData[i].lng,currentRouteData[j].lat,currentRouteData[j].lng) *1000;
        dist += distMeters;
        currentRouteData[j].dist = dist;
    }
    //For debugging of the currentRouteData array
    for(var i=0;i<currentRouteData.length-1;i++) {
        if(currentRouteData[i].instructions.length>0) {
            var turnLoc = new google.maps.LatLng(currentRouteData[i].lat,currentRouteData[i].lng);
            var turnTxt = currentRouteData[i].instructions;
            var turnMarker = new google.maps.Marker({
                position: turnLoc,
                map: map,
                draggable: true,
                visible: false,  //DEBUG this on and off
                title: turnTxt
            });
        }
    }
    //End debugging
    makePermalink();
    createSpacedPath();
    return;
}
//......................................................................................................
function getSingleElevation(i) {
    var Lat = useThis[i].lat;
    var Lng = useThis[i].lng;
    URL += Lat + "," + Lng;
    var LL = new google.maps.LatLng(useThis[i].lat,useThis[i].lng);
    var locations = []; locations.push(LL); var positionalRequest = {'locations': locations};
    elevator.getElevationForLocations(positionalRequest,function(results,status){
        if(status==google.maps.ElevationStatus.OK) {
            if(results[0]) useThis[i].height = parseFloat(results[0].elevation);
            else           useThis[i].height = "Height Unknown";
        }
        else               useThis[i].height = "Height Unknown";

        i++;
        if(i<useThis.length){
            if(i%100 == 0){
                $('#progress').remove();
                $('body').append('<div id="progress">Profiling...'+i+'/'+useThis.length+'</div>');
            }setTimeout(function(){getSingleElevation(i);} , 50);
        } else{
            $('#progress').remove();
            profileRoute();
        }
    }); return;
}
//......................................................................................................
function getMultipleElevations(i) {
    var locations = [];
    var start = i;
    var end = start + 250;
    end = Math.min(end,useThis.length);
    for(var j=start;j<end;j++){
        var Lat = useThis[j].lat;
        var Lng = useThis[j].lng;
        var LL = new google.maps.LatLng(Lat,Lng);
        locations.push(LL);
    }
    var positionalRequest = {'locations': locations};
    elevator.getElevationForLocations(positionalRequest,function(results,status){
        if(status==google.maps.ElevationStatus.OK) {
            if(results.length>0)
                for(var r=0;r<results.length;r++){
                    var j = start + r;
                    useThis[j].height = parseFloat(results[r].elevation);
                } else
                for(var j=start;j<end;j++)useThis[j].height = "Height Unknown";
        } else
            for(var j=start;j<end;j++)useThis[j].height = "Height Unknown";
        i = end;
        if(i<useThis.length){
            $('#progress').remove();
            $('body').append('<div id="progress">Profiling...'+i+'/'+useThis.length+'</div>');
            setTimeout(function(){getMultipleElevations(i);} , 50);
        }
        else{
            $('#progress').remove();
            profileRoute();
        }
    }); return;
}
//......................................................................................................
function profileRoute() {
    var Profile = new String();
    for(var i=0;i<useThis.length;i++) {
        Profile += useThis[i].dist + "\n";
    }
    //alert(Profile);
    var Profile = new String();
    for(var i=0;i<useThis.length;i++) {
        Profile += useThis[i].height + "\n";
    }
    //alert(Profile);
    //Make a smoothed version of the elevation profile to remove spikes.
    var runAve = 7;
    var istart;
    var iend;
    var aveArray = [];
    aveArray.length = 0;
    for(i=0; i<useThis.length; i++) {
        //Trivial case, but might as well handle it.
        if(useThis.length<runAve) {
            istart = 0;
            iend = useThis.length-1;
            runAve = iend - istart + 1;
        } else {
            //For every point, find runAve points that you can use to make an average
            istart = i - Math.floor(runAve/2);
            iend = istart + runAve -1;
            while(istart<0) {
                istart++;
                iend++;
            } while(iend>useThis.length-1) {
                istart--;
                iend--;
            }
            //OK, so you have the starting and ending positions
            var Average=0;
            var count = 0;
            for(var j=istart; j<iend+1; j++) {
                if(!isNaN(useThis[j].height)){
                    Average += useThis[j].height;
                    count++;
                }
            }
            if(count>0)
                Average /= count;
            else
                Average = 0;
            aveArray.push(Average);
        }
    }
    var Profile = new String();
    for(var i=0;i<aveArray.length;i++) {
        Profile += aveArray[i] + "\n";
    }
    //alert(Profile);
    var averageElevation = 0;
    var maxElevation = 0;
    var minElevation = 1000000;
    var pitch = 0;
    var maxPitch = -100; var maxPindex=0;
    var minPitch = 0;
    var countPeaks = 0;
    var countTroughs = 0;
    var delta = 2;

    for(var i=0;i<useThis.length;i++) {
        //Average
        averageElevation += aveArray[i];
        //Max and Min
        maxElevation = Math.max(maxElevation,aveArray[i]);
        minElevation = Math.min(minElevation,aveArray[i]);
        var minDist = 30;
        //Pitch.  For the pitch calculation, DO NOT use a calculation over a horizontal distance of <minDist meters.
        if(i<useThis.length-1) {
            var distMeters = 0;
            var j = i;
            while(distMeters<minDist) {
                j++;
                if(j>useThis.length-1)break;
                distMeters = useThis[j].dist-useThis[i].dist;
            }
            if(distMeters>=minDist)
                pitch = (useThis[j].height-useThis[i].height)/distMeters;
            else
                pitch = 0;
            //alert("Distance is " + distMeters + " and pitch is " + pitch*100);
            if(isNaN(pitch))pitch=0;
            useThis[i].pitch = pitch;
        } else if(i==useThis.length-1) {
            useThis[i].pitch = useThis[i-1].pitch;
        }
        if(useThis[i].pitch>maxPitch)maxPindex=i;
        maxPitch = Math.max(maxPitch,useThis[i].pitch);
        minPitch = Math.min(minPitch,useThis[i].pitch);

        //Peaks and Troughs
        if(i>0 && i<useThis.length-1) {
            var h = i-1;
            var j = i+1;
            if(aveArray[i]-aveArray[h]>delta && aveArray[i]-aveArray[j]>delta)
                useThis[i].peak = true;
            if(aveArray[h]-aveArray[i]>delta && aveArray[j]-aveArray[i]>delta)
                useThis[i].trough = true;
        }
        if(useThis[i].peak)countPeaks++;
        if(useThis[i].trough)countTroughs++;
    }
    averageElevation /= useThis.length;
    if(pitchMarker)pitchMarker.setMap(null);
    var location = new google.maps.LatLng(useThis[maxPindex].lat,useThis[maxPindex].lng);
    pitchMarker = new google.maps.Marker({
        position: location,
        map: map,
        icon: 'RLimages/steep.png',
        title: "Steepest Climb"
    });
    var ClimbRange = maxElevation - minElevation;
    document.getElementById("Climb").style.color = "red";
    document.getElementById("Grade").style.color = "red";
    if(ClimbRange>0 && ClimbRange<20)
        document.getElementById("Climb").innerHTML = "Easy(" + ClimbRange.toFixed(0) +"m)";
    if(ClimbRange>20 && ClimbRange<100)
        document.getElementById("Climb").innerHTML = "Ave(" + ClimbRange.toFixed(0) +"m)";
    if(ClimbRange>100 && ClimbRange<20000)
        document.getElementById("Climb").innerHTML = "Hard(" + ClimbRange.toFixed(0) +"m)";

    if(maxPitch*100>0 && maxPitch*100<7)
        document.getElementById("Grade").innerHTML = "Easy(" + (maxPitch*100).toFixed(1) +"%)";
    if(maxPitch*100>7 && maxPitch*100<12)
        document.getElementById("Grade").innerHTML = "Ave(" + (maxPitch*100).toFixed(1) +"%)";
    if(maxPitch*100>12 && maxPitch*100<500)
        document.getElementById("Grade").innerHTML = "Hard(" + (maxPitch*100).toFixed(1) +"%)";
    //alert("Climb range = " + ClimbRange + " Pitch = " + maxPitch*100 +"%" + " at " + useThis[maxPindex].dist/1000 + " km.");
}
//......................................................................................................
function attachInstructionText(marker, text) {
    google.maps.event.addListener(marker, 'click', function() {
        stepDisplay.setContent(text);
        stepDisplay.open(map, marker);
    });
    google.maps.event.addListener(marker, 'mouseover', function() {
        stepDisplay.setContent(text);
        stepDisplay.open(map, marker);
    });
    return;
}
//.................................................
function makePermalink() {
    var currentURL = location.href;
    var permalink;
    //Create a permalink using the current route.  All that is really needed to reproduce this route are the base location,
    //the number of waypoints, the waypoints themselves, and the travel mode.
    var protocol = location.protocol;
    var host = location.host;
    var path = location.pathname;
    var extra;
    var wptString;
    wptString = "numWpts=" + routeResult.routes[0].legs[0].via_waypoint.length + "&";
    for(var i=0;i<routeResult.routes[0].legs[0].via_waypoint.length;i++)
        wptString = wptString + "wpt[" + i + "]=" + routeResult.routes[0].legs[0].via_waypoint[i].location.lat() +
            ":" + routeResult.routes[0].legs[0].via_waypoint[i].location.lng() +"&";
    extra = "?Base="+BaseLocation.lat()+":"+BaseLocation.lng()+"&"+wptString;
    extra = extra + "tM=" + travelMode;
    extra = extra + "&len=" + document.getElementById("length").value;
    extra = extra + "&unitS=" + document.getElementById("unitSystem").value;
    extra = extra + "&doClean=" + DoClean;
    permalink = protocol+"//"+host+path + extra;
    document.getElementById("permalink").href = permalink;
    //Make a version that will take you to the OSM version, with this route.
    permalink = protocol+"//"+host+path+"/OSM" + extra;
    document.getElementById("OSMversion").href = permalink;
    return;
}
//.........................................................................................................
function writeCookies() {
    //Write cookies.
    var CookieAddress = document.getElementById("address").value;
    var CookieLength  = document.getElementById("length").value;
    var CookieTM      = document.getElementById("travelMode").value;
    var CookieTD      = document.getElementById("travelDirection").value;
    var CookieUS      = document.getElementById("unitSystem").value;
    var CookieClean   = document.getElementById("toggleClean").value;
    createCookie("address",CookieAddress);
    createCookie("length",CookieLength);
    createCookie("TM",CookieTM);
    createCookie("TD",CookieTD);
    createCookie("US",CookieUS);
    createCookie("Clean",CookieClean);
    return;
}
//..............................................................................................
function storeURL() {
    // This is the same as the permalink thing above, but just make the string.  Don't do anything with it.
    var storedURL;
    var protocol = location.protocol;
    var host = location.host;
    var path = location.pathname;
    var extra;
    var wptString;
    wptString = "numWpts=" + routeResult.routes[0].legs[0].via_waypoint.length + "&";
    for(var i=0;i<routeResult.routes[0].legs[0].via_waypoint.length;i++)
        wptString = wptString + "wpt[" + i + "]=" + routeResult.routes[0].legs[0].via_waypoint[i].location.lat() +
            ":" + routeResult.routes[0].legs[0].via_waypoint[i].location.lng() +"&";
    extra = "?Base="+BaseLocation.lat()+":"+BaseLocation.lng()+"&"+wptString;
    extra = extra + "tM=" + travelMode;
    extra = extra + "&len=" + document.getElementById("length").value;
    extra = extra + "&unitS=" + document.getElementById("unitSystem").value;
    storedURL = protocol+"//"+host+path + extra;
    return storedURL;
}
//.................................................................................................
function parseUrl(currentURL) {
    var returnStatus = new Boolean();
    var urlInputsName = [];
    var urlInputsValue = [];
    var p1,p2,val;
    returnStatus = false;
    // Add a section to see if we have a URL from an embedded link (maplet, gadget, whatever).
    haveEmbedded = false;
    p1 = currentURL.indexOf("URLformat");
    if(p1>0) {
        //We have a format tag, so keep going
        p1 = currentURL.indexOf("=",p1)+1;
        p2 = currentURL.indexOf("&",p1);
        val = currentURL.substring(p1,p2);
        if(val=="embed") {
            p1 = currentURL.indexOf("&",p2)+1;
            p2 = currentURL.indexOf("=",p1)+1;
            val = currentURL.substring(p1,p2);
            if(val=="Base=") {
                p1 = p2;
                p2 = currentURL.indexOf("&",p1);
                val = currentURL.substring(p1,p2);
                var Eaddress = val.replace(/%20/g," ");
            } else return;
            p1 = p2+1;
            p2 = currentURL.indexOf("=",p1)+1;
            val = currentURL.substring(p1,p2);
            if(val=="len=") {
                p1 = p2;
                p2 = currentURL.length;
                val = currentURL.substring(p1,p2);
                var Elength = parseFloat(val);
                haveEmbedded = true;
                document.getElementById("address").value = Eaddress;
                codeAddress();
                document.getElementById("length").value = Elength.toFixed(2);
                return;
            } else return;
        } else return; //This shouldn't happen, so just get out.
    }//else //No format tag, so try the rest of this function.

    /* Add in a new section here.  Find out if there is an OLD permalink here. */
    /* NOTE ON TESTING THIS: this all works fine if you check the code in the same place.  That is, if you generate an old permalink
       using the local server, then you can check that the new code works correctly when you call the RL engine on the local server.
       And if you generate the link on the commercial server, then check by calling the engine on the commercial server. Don't mix the
       two servers.  The results will not match. */
    if(currentURL.indexOf("zoom")>0) {
        haveOldUrl = false;
        //alert("We appear to have an old URL to deal with.");
        // Get lat and lon
        p1 = currentURL.indexOf("ll=") + 3;
        p2 = currentURL.indexOf("%20",p1);
        val = currentURL.substring(p1,p2);
        if(val.length>0) {
            oldUrlLng = parseFloat(val);
        } else return;
        //alert("The extracted LNG is " + oldUrlLng);
        p1 = p2+3;
        p2 = currentURL.indexOf("&",p1);
        val = currentURL.substring(p1,p2);
        if(val.length>0) {
            oldUrlLat = parseFloat(val);
        } else return;
        //alert("The extracted LAT is " + oldUrlLat);
        p1 = p2+5;
        p2 = currentURL.indexOf("&",p1);
        val = currentURL.substring(p1,p2);
        if(val.length>0) {
            oldUrlLen = parseFloat(val)*5280*12*2.54/100;
        } else return;
        //alert("The extracted LEN is " + oldUrlLen);
        p1 = p2+4;
        p2 = currentURL.indexOf("&",p1);
        val = currentURL.substring(p1,p2);
        if(val.length>0) {
            oldUrlRnd = parseFloat(val);
        } else return;
        //alert("The extracted RND is " + oldUrlRnd);
        p1 = p2+4;
        p2 = currentURL.indexOf("&",p1);
        val = currentURL.substring(p1,p2);
        if(val.length>0) {
            oldUrlAllow = val;
        } else return;
        //alert("The extracted ALLOW is " + oldUrlAllow);
        //If you reach this point, then:
        haveOldUrl = true;
        return;
    }
    //else, just continue with the rest of the routine.
    var firstSplit = currentURL.split("?");
    if(firstSplit.length==2) {
        var secondSplit = firstSplit[1].split("&");
        for(var i=0;i<secondSplit.length;i++) {
            var hold = secondSplit[i].split("=");
            urlInputsName[i] = hold[0];
            urlInputsValue[i] = hold[1];
        }
        if(urlInputsName[0]=="Base") {
            var hold = urlInputsValue[0].split(":");
            var Lat = parseFloat(hold[0]);
            var Lng = parseFloat(hold[1]);
            uBase = new google.maps.LatLng(Lat,Lng);
        } else {return returnStatus;}
        if(urlInputsName[1]=="numWpts") {
            var numWpts = parseInt(urlInputsValue[1]);
        } else {return returnStatus;}
        for(var i=0;i<numWpts;i++) {
            if(urlInputsName[i+2]=="wpt["+i+"]") {
                var hold = urlInputsValue[i+2].split(":");
                var Lat = parseFloat(hold[0]);
                var Lng = parseFloat(hold[1]);
                urlPoints[i] = new google.maps.LatLng(Lat,Lng);
            } else {return returnStatus;}
        }
        if(urlInputsName[numWpts+2]=="tM") {
            utM = parseInt(urlInputsValue[numWpts+2]);
        } else {return returnStatus;}
        if(urlInputsName[numWpts+3]=="len") {
            ulen = parseFloat(urlInputsValue[numWpts+3]);
        } else {return returnStatus;}
        if(urlInputsName[numWpts+4]=="unitS") {
            uuS = parseInt(urlInputsValue[numWpts+4]);
        }
        else {return returnStatus;}
        if(urlInputsName[numWpts+5]=="doClean") {
            uClean = (urlInputsValue[numWpts+5]);
            returnStatus = true;
            return returnStatus;
        }
        else{//Don't require this doClean tag.
            uClean=false;
            returnStatus = true;
            return returnStatus;
        }
    } else {return returnStatus;}
}
//...............................................................................
function buildDirections(directionResult) {
    var myRoute = directionResult.routes[0].legs[0];
    var step = myRoute.steps.length;
    var cumulative=0;
    var cumWrite;
    Directions  = "<table border=1 rules=1>";
    Directions += "<tbody>";
    Directions += "<tr>";
    Directions += "<th colspan=4 align=left bgcolor='#ffec8b'>";
    Directions += "Start: " + myRoute.start_address;
    Directions += "</th>";
    Directions += "</tr>";
    Directions += "<tr>";
    Directions += "<td colspan=4 align=left>";
    Directions += "Total distance is " + totalDistanceInCurrentUnits.toFixed(2);
    if(document.getElementById("unitSystem").value==0)
        Directions += " mi.";
    else
        Directions += " km.";
    Directions += "</td>";
    Directions += "</tr>";
    if(directionResult.routes[0].warnings.length>0) {
        Directions += "<tr>";
        Directions += "<td colspan=4 align=left>";
        Directions += "<strong><i>" + directionResult.routes[0].warnings[0] + "</i></strong>";
        Directions += "</td>";
        Directions += "</tr>";
    }
    Directions += "<tr>";
    Directions += "<td></td> <td>Instruction</td> <td>Dist.</td> <td>Cum.<br>Dist.</td>";
    Directions += "</tr>";
    for(var i=0;i<step;i++) {
        Directions += "<tr>";
        cumulative += myRoute.steps[i].distance.value;
        if(document.getElementById("unitSystem").value==0)
            cumWrite = cumulative*100/2.54/12/5280.;
        else
            cumWrite = cumulative/1000;
        Directions += "<td>";
        Directions += i+1 +".";
        Directions += "</td>";
        Directions += "<td>";
        Directions += "<a href=\"javascript:showDirectionFlag("+i+")\">";
        Directions += myRoute.steps[i].instructions;
        Directions += "</a>";
        Directions += "</td>";
        Directions += "<td width='15%'>";
        Directions += myRoute.steps[i].distance.text;
        Directions += "</td>";
        Directions += "<td width='15%'>";
        if(document.getElementById("unitSystem").value==0)
            Directions += cumWrite.toFixed(2) + "mi";
        else
            Directions += cumWrite.toFixed(2) + "km";
        Directions += "</td>";
        Directions += "</tr>";
    }
    Directions += "<tr>";
    Directions += "<th colspan=4 align=left bgcolor='#ffec8b'>";
    // What follows is a sad little hack, because somehow end_address is not showing up in the response :-(  (Fixed now!!!)
    if(myRoute.end_address!=null)Directions += "End: " + myRoute.end_address;
    else Directions += "End: " + myRoute.start_address;
    Directions += "</th>";
    Directions += "</tr>";
    Directions += "<tr>";
    Directions += "<td colspan=4 align=left>";
    Directions += "<strong>" + directionResult.routes[0].copyrights + "</strong>";
    Directions += "</td>";
    Directions += "</tr>";
    Directions += "</tbody>";
    Directions += "</table>";
    document.getElementById("mydirectionsPanel").innerHTML = Directions;
}
//...........................................................................................
function revertToPreviousRoute() {
    historyPointer--;
    historyPointer = Math.max(historyPointer,0);

    thisRoute = resultHistory[historyPointer].RouteData.routes[0].legs[0];
    putTheseSettings(resultHistory[historyPointer].Settings);

    BaseLocation = new google.maps.LatLng(thisRoute.start_location.lat(),thisRoute.start_location.lng());
    document.getElementById("address").value = BaseLocation.toString();
    createBaseMarker();
    codeAddress();
    rlPoints.length = 0;
    for(var i=0;i<thisRoute.via_waypoint.length;i++)
        rlPoints.push(thisRoute.via_waypoint[i].location);

    document.getElementById("travelMode").value==resultHistory[historyPointer].Settings.travelMode;

    storeInHistory=false;
    if(pitchMarker)pitchMarker.setMap(null);
    calcRoute();
    return;
}
//....................................................................................
function advanceToNextRoute() {
    historyPointer++;
    historyPointer = Math.min(historyPointer,resultHistory.length-1);
    thisRoute = resultHistory[historyPointer].RouteData.routes[0].legs[0];
    putTheseSettings(resultHistory[historyPointer].Settings);
    BaseLocation = new google.maps.LatLng(thisRoute.start_location.lat(),thisRoute.start_location.lng());
    document.getElementById("address").value = BaseLocation.toString();
    createBaseMarker();
    codeAddress();
    rlPoints.length = 0;
    for(var i=0;i<thisRoute.via_waypoint.length;i++)
        rlPoints.push(thisRoute.via_waypoint[i].location);
    document.getElementById("travelMode").value==resultHistory[historyPointer].Settings.travelMode;
    storeInHistory=false;
    if(pitchMarker)pitchMarker.setMap(null);
    calcRoute();
    return;
}
//....................................................................................
function createCookie(name, value, days) {
    if (days) {
        var date = new Date();
        date.setTime(date.getTime()+(days*24*60*60*1000));
        var expires = "; expires="+date.toGMTString();
    }
    else var expires = "";
    document.cookie = name + "=" + encodeURIComponent(value) + expires + "; path=/ ";
    return;
}
//......................................................................................
function readCookie(name) {
    var ca = document.cookie.split(';');
    var nameEQ = name + "=";
    for(var i=0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0)==' ') c = c.substring(1, c.length); //delete spaces
        if (c.indexOf(nameEQ) == 0) return decodeURIComponent(c.substring(nameEQ.length, c.length));
    } return null;
}
//........................................................................................
function cleanTails(response) {
    //alert("Calling cleanTails!!!!");
    var pLpoints = new Array();
    var pLdist = new Array();
    var pLclose = new Array();
    var pLsep = new Array();
    var newPath = new Array();
    var pLuse = new Array();
    for(var i=0;i<routeLatLng.length;i++) {
        pLpoints.push(routeLatLng[i].location);
    }
    pLdist.push(0);
    var cumulative = 0;
    for(var i=0;i<pLpoints.length-1;i++) {
        pLuse[i] = false;
        cumulative += LatLngDist(pLpoints[i].lat(),pLpoints[i].lng(),pLpoints[i+1].lat(),pLpoints[i+1].lng());
        pLdist.push(cumulative);
        newPath.push(pLpoints[i]);
    } newPath.push(pLpoints[pLpoints.length-1]);
    //alert("Cumulative distance is " + cumulative);

    //Find the point, ahead of each point, to which each point is closest.
    var closest;
    var point;
    var dist;
    for(var i=0;i<pLpoints.length;i++) {
        var thisOne = pLpoints[i];
        for(var j=i+1;j<pLpoints.length;j++) {
            thatOne = pLpoints[j];
            dist = LatLngDist(thisOne.lat(),thisOne.lng(),thatOne.lat(),thatOne.lng());
            if(j==i+1) //initialize
            {
                closest = dist;
                point = j;
            }
            else {
                if(dist<closest) //store this point
                {
                    closest = dist;
                    point = j;
                }
            }
        }
        pLclose[i] = point;
        pLsep[i] = closest;
    }
    var tailSize;
    for(var i=0;i<pLpoints.length;i++) {
        pLuse[i] = true;
        if(pLclose[i]-i != 1) //indicates a potential tail
        {
            tailSize = (pLdist[pLclose[i]] - pLdist[i])/cumulative;
            if(tailSize<0.2) {
                /*
	      var marker = new google.maps.Marker({
		position: pLpoints[i],
		    map: map
		    });
	      attachInstructionText(marker, "Tail between" + i +","+ pLclose[i]);
	      */
                i = pLclose[i]; //Jump ahead, over this tail.
            }
        }
    }
    newPath.length = 0;
    for(var i=0;i<pLpoints.length;i++)
        if(pLuse[i])
            newPath.push(pLpoints[i]);
    var cleanedUp = pLpoints.length - newPath.length;

    //This may not be the best way, but I would like to find the points in this new path that are closest to the existing waypoints, and
    //replace the existing waypoints with these new points.
    thisRoute = response.routes[0].legs[0];
    rlPointsNew.length = 0;
    for(var i=0;i<thisRoute.via_waypoint.length;i++) {
        for(var j=0;j<newPath.length;j++) {
            dist = LatLngDist(thisRoute.via_waypoint[i].location.lat(),thisRoute.via_waypoint[i].location.lng(),newPath[j].lat(),newPath[j].lng());
            if(j==0) {
                closest=dist;
                point=j;
            } else {
                if(dist<closest) {
                    closest = dist;
                    point=j;
                }
            }
        } rlPointsNew.push(newPath[point]);
    }
    rlPoints.length = 0;
    for(var i=0;i<rlPointsNew.length;i++)rlPoints.push(rlPointsNew[i]);
    //Don't let it move anything that is fixed.
    for(var i=0;i<fixedPoints.length;i++)rlPoints[i] = fixedPoints[i].marker.getPosition();
    return cleanedUp;
}
//...............................................................
function compareToPlan(response) {
    retflag = true;
    var myRoute = response.routes[0].legs[0];
    // Check here to see if the route is just ridiculously off of plan.  Say by x2 or more.
    var length = document.getElementById("length").value;
    if(document.getElementById("unitSystem").value == 0)
        length = length*5280*12*2.54/100;
    else
        length = length*1000;
    var ratio  = myRoute.distance.value/length;
    if(ratio>2) {
        if(document.getElementById("unitSystem").value == 0) {
            var have = myRoute.distance.value*100/2.54/12/5280;
            var want = length*100/2.54/12/5280;
        }
        else {
            var have = myRoute.distance.value/1000;
            var want = length/1000;
        }
        var answer = confirm("The current route length (" +have.toFixed(2)+ ") is too far from the requested distance (" +want.toFixed(2)+ "). \nClick 'OK' to update the desired route length and use this route. \nClick 'Cancel' to delete this route and generate a new one.");
        if(answer) {
            document.getElementById("length").value = have;
            length = have;
            retflag = true;
        } else
            retflag = false;
    }
    else {
        retflag = true;
    }
    // Here let's look for ferries.  If there are any, kill the route based on user preference.
    if(!allowFerries) {
        for(var i=0;i<myRoute.steps.length;i++) {
            var tmp = myRoute.steps[i].instructions.toLowerCase();
            if(tmp.indexOf("take the") >-1 && tmp.indexOf("ferry") > -1) {
                //alert("Ferry! " + myRoute.steps[i].instructions);
                retflag = false;
            }
        }
    } return retflag;
}
//............................................................................
function getLength() {
    var length = document.getElementById("length").value;
    if(document.getElementById("unitSystem").value == 0) {
        length = length*5280*12*2.54/100;
        tcxSpeed = document.getElementById("tcxSpeed").value *(5280*12*2.54/100) /(60*60); //Convert to meters/second
    }
    else {
        length = length*1000;
        tcxSpeed = document.getElementById("tcxSpeed").value *(1000) /(60*60); //Convert to meters/second
    }
    requestedLengthInMeters = length;
    targetLengthInMeters = length;
    document.getElementById("GoButton").innerHTML="Create a Route of this Length";
    resetScale();
    return;
}
//....................................................................
function adjustScale() {
    //Allow this scaling to change, based on how the program is doing at generating routes.
    if(totalDistanceInCurrentUnits==0) {
        scaleFactor = 0.80;
        scaleCount++;
        tooLong = 0;
        tooShort = 0;
    }
    else if (totalDistanceInCurrentUnits!=0 && scaleCount==0) {
        scaleCount++;
        tooLong = 0;
        tooShort = 0;
    }
    else if (totalDistanceInCurrentUnits!=0 && scaleCount!=0) {
        var lWanted = document.getElementById("length").value;
        if(totalDistanceInCurrentUnits<lWanted*0.9) {
            tooLong = 0;
            tooShort++;  //The routes are too short
        }
        else if(totalDistanceInCurrentUnits>lWanted*1.1) {
            tooShort = 0;
            tooLong++;  //The routes are too long
        }
        else // the route is fine.
        {
            tooLong = 0;
            tooShort = 0;
        }
        if(tooShort>2) //it's been too short for too long
        {
            scaleFactor += 0.02;
            scaleFactor = Math.min(scaleFactor,1.3);
            tooShort = 0;
            targetLengthInMeters *= scaleFactor;
        }
        if(tooLong>2) //it's been too long for too long
        {
            scaleFactor -= 0.02;
            scaleFactor = Math.max(scaleFactor,0.7);
            tooLong = 0;
            targetLengthInMeters *= scaleFactor;
        }
    } return;
}
//....................................................................
function resetScale() {
    scaleCount = 0;
    scaleFactor = 0.80;
    tooLong = 0;
    tooShort = 0;
    return;
}
//......................................................................
function createSpacedPath() {
    //The goal here is to create a version of the path that we now have, but with points more evenly spaced than
    //those returned by Google.
    spacedRouteData.length = 0;
    var spacing = 50; //the spacing between points in meters.  About 800 points in a 25 mile route.
    var inPoints = currentRouteData.length;
    var routeLength = currentRouteData[inPoints-1].dist;

    //So, store the first point in this new array.
    var Lat = currentRouteData[0].lat;
    var Lng = currentRouteData[0].lng;
    var temp = new routeData(Lat,Lng,0,0,0,false,false,"",false);
    spacedRouteData.push(temp);

    var currentDist = 0;
    var istart;
    while(currentDist<routeLength) {
        currentDist += spacing;
        if(currentDist>=routeLength)break;
        for(var i=0;i<inPoints;i++)
            if(currentRouteData[i].dist>currentDist)
                break;
        var j = i;
        i--;
        //OK, we have the points we want to use.  Now interpolate between those points.
        //Lots of good material at http://www.movable-type.co.uk/scripts/latlong.html.
        var distToGo = currentDist - currentRouteData[i].dist;
        var Lat1 = currentRouteData[i].lat;
        var Lon1 = currentRouteData[i].lng;
        var Lat2 = currentRouteData[j].lat;
        var Lon2 = currentRouteData[j].lng;
        var lat1 = Lat1*Math.PI/180;
        var lat2 = Lat2*Math.PI/180;
        var lon1 = Lon1*Math.PI/180;
        var lon2 = Lon2*Math.PI/180;
        var R = 6371; // km
        var dLat = (lat2-lat1);
        var dLon = (lon2-lon1);

        //Get the bearing
        var y = Math.sin(dLon) * Math.cos(lat2);
        var x = Math.cos(lat1)*Math.sin(lat2) -
            Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
        var brng = Math.atan2(y, x);

        //Now get the destination, given the starting point and the bearing
        var d = distToGo/1000;  //in km.
        var lat3 = Math.asin( Math.sin(lat1)*Math.cos(d/R) +
            Math.cos(lat1)*Math.sin(d/R)*Math.cos(brng) );
        var lon3 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(d/R)*Math.cos(lat1),
            Math.cos(d/R)-Math.sin(lat1)*Math.sin(lat3));
        var Lat3 = lat3*180/Math.PI;
        var Lon3 = lon3*180/Math.PI;

        var temp = new routeData(Lat3,Lon3,currentDist,0,0,false,false,"",false);
        spacedRouteData.push(temp);
    }
    var Lat = currentRouteData[inPoints-1].lat;
    var Lng = currentRouteData[inPoints-1].lng;
    var temp = new routeData(Lat,Lng,routeLength,0,0,false,false,"",false);
    spacedRouteData.push(temp);
    return;
}
//...................................................................................
function makeHistory(result) {
    var settingObject = new Object;
    settingObject.travelMode = document.getElementById("travelMode").value;
    settingObject.direction = document.getElementById("travelDirection").value;
    settingObject.heading = document.getElementById("travelHeading").value;
    settingObject.unit = document.getElementById("unitSystem").value;
    resultHistory.push({RouteData:result, Settings:settingObject});
    return;
}
//................................................................................
function putTheseSettings(settingObject) {
    document.getElementById("travelMode").value = settingObject.travelMode;
    document.getElementById("travelDirection").value = settingObject.direction;
    document.getElementById("travelHeading").value = settingObject.heading;
    document.getElementById("unitSystem").value = settingObject.unit;
    return;
}
//.............................................
function rotateMessages() {
    rotateIndex++;
    if(rotateIndex>rotatingMessages.length-1)rotateIndex=0;
    // document.getElementById("Billboard").innerHTML = rotatingMessages[rotateIndex];
    return;
}
//...............................................
function BBgo() {
    if(!iAmRotating) {
        iAmRotating = true;
        if(rotateIndex<0)
            rotateIndex = Math.min(rotatingMessages.length-1,parseInt(Math.random()*rotatingMessages.length));
        // document.getElementById("Billboard").innerHTML = rotatingMessages[rotateIndex];
        rotatingMessage = setInterval(rotateMessages,30000);
    } else {
        iAmRotating = false;
        clearInterval(rotatingMessage);
    } return;
}
//.................................................................................................................
function showCrime() {
    var radius = 0.05;
    var lat = BaseLocation.lat();
    var lng = BaseLocation.lng();

    if (!showingCrime)  //You are not showing crime and you want to.
    {
        showingCrime = true;
        document.getElementById("showCrime").value = "Turn crime activity off";
        loadCrimes(lat,lng,radius);
    }
    else if (showingCrime) //You are showing them, and you want to stop.
    {
        showingCrime = false;
        document.getElementById("showCrime").value = "Turn crime activity on";
        $.each(crime_markers, function(index, value) {
            value.setMap(null);
        });
        crime_markers = [];
    }
}

function loadCrimes(lat, lng, radius) {
    if (typeof(radius) === 'undefined' || radius === null) { radius = 0.05; }
    $.each(crime_markers, function(index, value) {
        value.setMap(null);
    });
    crime_markers = [];

    var url = "//api.spotcrime.com/crimes.json?";
    url += "lat="+lat;
    url += "&lon="+lng;
    url += "&radius="+radius;
    url += "&callback=?";
    url += "&key=privatekeyforspotcrimepublicusers-commercialuse-877.410.1607";

    $.getJSON(url, function(data) {
        if (data === null) {
            $('#table_container').empty();
            $('#table_container2').empty();
            $('#table_container3').empty();
            return;
        }

        var bounds = new google.maps.LatLngBounds();
        var totalCount = data.crimes.length;

        /* render crimes */
        $('#table_container').empty();
        $('#table_container2').empty();
        $('#table_container3').empty();
        $.each(data.crimes, function(index, crime) {
            var spriteX = spritePosition(crime.type);
            var zIndex = totalCount - index;
            if (crime.type == "Other") {
                zIndex = 0;
            }
            var link = crime.link;
            link = link.replace('https://spotcrime.com/crime/', 'https://spotcrime.com/mobile/crime/?')

            /* render marker */
            var marker = new google.maps.Marker({
                map: map,
                zIndex: zIndex,
                position: new google.maps.LatLng(crime.lat, crime.lon),
                // icon: new google.maps.MarkerImage('../images/icons/spotcrime_info/spotcrime-icons-sprite.png', new google.maps.Size(30, 25), new google.maps.Point(spriteX, 0)),
                icon: new google.maps.MarkerImage('//s3.amazonaws.com/s3.mylocalcrime.com/images/icons/spotcrime_info/spotcrime-icons-sprite.png', new google.maps.Size(30, 25), new google.maps.Point(spriteX, 0)),
                title: crime.type
            });
            bounds.extend(marker.getPosition());
            var infowindow_content = '<div class="infowindow"><h4>' + crime.type + '</h4><p>' + crime.address + '</p><p>' + crime.date + '</p><p><a href="' + link + '" target="_blank">More information</a></p></div>';
            google.maps.event.addListener(marker, 'click', function(event) {
                infowindow.setContent(infowindow_content);
                infowindow.open(map, marker);
            });
            crime_markers.push(marker);

            /* listing */
            $record = $(
                '<a href="' + link + '" target="_blank" class="list-group-item clearfix">' +
                '<h4 class="list-group-item-heading"><div class="crime-type crime-type-' + crime.type.toLowerCase() + '"><span /></div>' + crime.type + '</h4>' +
                '<p class="list-group-item-text crime-date">' + crime.date + '</p>' +
                '<p class="list-group-item-text crime-address">' + crime.address + '</p>' +
                '</a>');

            if (index < 2) {
                $('#table_container').append($record);
            }
            else if (index >= 2 && index < 7) {
                $('#table_container2').append($record);
            }
            else {
                $('#table_container3').append($record);
            }
        });
    });
}

function spritePosition(type) {
    return {
        "Arrest":     0,
        "Arson":      30,
        "Assault":    60,
        "Burglary":   90,
        "Other":      120,
        "Robbery":    150,
        "Shooting":   180,
        "Theft":      210,
        "Vandalism":  240
    }[type];
}
